<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Applicant Tracker - Job Position</title>
    <link rel="stylesheet" href="/css/sidebar.css"> <!-- Linking Sidebar CSS -->
    <link rel="stylesheet" href="/css/linemanager.css"> <!-- Linking Main Content CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css"> <!-- FontAwesome for icons -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css" rel="stylesheet">
    <style>
/* Main Layout Styles */
body {
    font-family: 'Inter', sans-serif;
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

.main-content {
    margin-left: 350px;
    padding: 20px;
    width: calc(100% - 350px);
    background-color: #FFFFFF;
}

/* Header Styles */
.header-section {
    margin-bottom: 10px;
    margin-left: 5px;
    font-size: 24px;
    text-align: left;
}

.subheader {
    font-size: 20px;
    margin-left: 5px;
    margin-bottom: 20px;
    color: #555;
}

/* Filter Section Styles */
.filter-section {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 20px;
}

.right-section {
    display: flex;
    gap: 10px;
    margin-bottom: 15px;
}

.right-section button, 
.filter-button {
    padding: 10px 15px;
    font-size: 16px;
    font-weight: bold;
    border: none;
    background-color: #124A5C;
    color: white;
    border-radius: 4px;
    cursor: pointer;
    transition: background-color 0.3s ease;
}

.right-section button:hover, 
.filter-button:hover {
    background-color: #B4E3E3;
    color: #124A5C;
}

.filter-button.active {
    background-color: #07ACB9;
    color: white;
}

/* Search Container Styles */
.search-container {
    display: flex;
    align-items: center;
    margin-bottom: 15px;
}

.search-bar {
    padding: 8px;
    width: 370px;
    font-size: 16px;
    border: 1px solid #ddd;
    border-radius: 4px;
}

.search-button {
    margin-left: 10px;
    background-color: #124A5C;
    color: white;
    border: none;
    padding: 10px;
    cursor: pointer;
    font-size: 16px;
    border-radius: 4px;
}

.search-button:hover {
    background-color: #B4E3E3;
    color: #124A5C;
}

/* Divider Style */
.divider {
    height: 2px;
    background-color: #124A5C;
    margin: 10px 0;
}

/* Sort Section Styles */
.sort-section {
    display: flex;
    align-items: center;
    margin: 10px 0;
}

.sort-section label {
    margin-right: 10px;
    font-weight: bold;
}

.sort-section select {
    padding: 8px;
    border: 1px solid #ddd;
    border-radius: 4px;
    background-color: white;
}

/* Table Styles */
.tracking-table {
    width: 100%;
    border-collapse: collapse;
    margin-bottom: 20px;
}

.tracking-table th, 
.tracking-table td {
    padding: 10px;
    border: 1px solid #ddd;
    text-align: left;
}

.tracking-table th {
    background-color: #f5f5f5;
    font-weight: bold;
}

.tracking-table th:nth-child(1),
.tracking-table td:nth-child(1) {
    width: 10%;
}

.tracking-table th:nth-child(2),
.tracking-table td:nth-child(2) {
    width: 20%;
}

.tracking-table th:nth-child(3),
.tracking-table td:nth-child(3),
.tracking-table th:nth-child(4),
.tracking-table td:nth-child(4) {
    width: 15%;
}

.tracking-table tr:hover {
    background-color: #f1f1f1;
}

/* Status Circle Styles */
.status-circle {
    width: 12px;
    height: 12px;
    border-radius: 50%;
    display: inline-block;
    margin-right: 8px;
}

.status-circle.green {
    background-color: green;
}

.status-circle.gray {
    background-color: gray;
}

/* Button Styles */
.btn-review, 
.btn-evaluation, 
.btn-onboarding, 
.btn-approve {
    background-color: white;
    color: black;
    border: 1px solid #124A5C;
    padding: 10px 20px;
    cursor: pointer;
    border-radius: 5px;
    font-size: 14px;
    transition: background-color 0.3s ease, color 0.3s ease;
    min-width: 150px;
    text-align: center;
    margin-top: 5px;
}

.btn-review:hover, 
.btn-evaluation:hover, 
.btn-onboarding:hover, 
.btn-approve:hover {
    background-color: #124A5C;
    color: white;
}

.set-interview-button {
    padding: 10px 20px;
    background-color: #124A5C;
    color: white;
    border: none;
    cursor: pointer;
    font-size: 16px;
    margin-top: 20px;
    display: block;
    width: 20%;
    text-align: center;
    border-radius: 5px;
}

.set-interview-button:hover {
    background-color: #B4E3E3;
    color: #124A5C;
}

.set-finalize-review-button {
    margin: 5px 10px;
    background-color: #124A5C;
    color: white;
    border: none;
    padding: 10px 20px;
    cursor: pointer;
    border-radius: 5px;
    width: auto;
    min-width: 200px;
    white-space: nowrap;
    text-align: center;
    font-size: 16px;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    transition: background-color 0.3s ease;
}

.set-finalize-review-button:hover {
    background-color: #B4E3E3;
    color: #124A5C;
}

.finalize-container {
    display: flex;
    flex-direction: column;
    position: fixed;
    bottom: 20px;
    right: 20px;
    background-color: rgba(255, 255, 255, 0.9);
    border: 1px solid #ccc;
    padding: 10px;
    border-radius: 10px;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    z-index: 1000;
}

/* Modal Styles */
.modal, .review-modal {
    display: none;
    position: fixed;
    z-index: 1000;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    overflow: auto;
    background-color: rgba(0, 0, 0, 0.4);
}

.modal-content, .review-modal-content {
    background-color: #fefefe;
    margin: 10% auto;
    padding: 20px;
    border: 1px solid #888;
    border-radius: 8px;
    width: 50%;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    text-align: center;
}

.close-button, .review-close-button {
    color: #aaa;
    float: right;
    font-size: 28px;
    font-weight: bold;
    cursor: pointer;
}

.close-button:hover,
.close-button:focus,
.review-close-button:hover,
.review-close-button:focus {
    color: black;
    text-decoration: none;
}

.modal-header, 
.modal-body, 
.modal-footer {
    text-align: center;
}

.modal-buttons, .review-modal-buttons {
    display: flex;
    justify-content: center;
    margin-top: 20px;
    gap: 10px;
}

.modal-buttons button, 
.review-modal-buttons button {
    padding: 10px 20px;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    font-size: 16px;
    transition: background-color 0.3s ease;
}

.back-button, .review-modal-back-button {
    background-color: rgba(18, 74, 92, 0.5);
    color: white;
}

.confirm-button, .review-modal-pass-button {
    background-color: #124A5C;
    color: white;
}

.review-modal-reject-button {
    background-color: #dc3545;
    color: white;
}

.modal-buttons button:hover, 
.review-modal-buttons button:hover {
    opacity: 0.8;
}

.modal-question {
    text-align: center;
    margin: 20px 0;
    font-size: 16px;
}

/* Decision Disclaimer */
.decision-disclaimer {
    background-color: #f8f9fa;
    border: 1px solid #ddd;
    border-radius: 5px;
    padding: 10px;
    margin: 15px 0;
    text-align: left;
    font-size: 14px;
}

/* Scores Table Styles */
.scores-table {
    width: 100%;
    border-collapse: collapse;
    margin: 15px 0;
}

.scores-table th, 
.scores-table td {
    padding: 8px;
    border: 1px solid #ddd;
    text-align: left;
}

.scores-table th {
    background-color: #f5f5f5;
}

.computation-verdict {
    margin: 15px 0;
    padding: 10px;
    background-color: #e9f7fe;
    border-radius: 5px;
    text-align: center;
    font-size: 16px;
}

/* Styling for applicant status section */
.applicant-status-section {
    background-color: #FFFFFF;
    padding: 20px;
    border-radius: 5px;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
    margin: 10px 5px 20px;
    display: none; /* Hidden by default */
}

/* Improved heading visibility */
.applicant-status-section h3.subheader {
    color: #124A5C;
    margin-bottom: 15px;
    font-size: 20px;
    font-weight: bold;
}
/* CSS to fix the header layout */
/* Enhanced CSS for section header and divider */
.applicant-status-section .section-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 0; /* Remove bottom margin to place divider closer */
    width: 100%;
}

.applicant-status-section .section-header h3.subheader {
    margin: 0;
    color: #124A5C;
    font-weight: bold;
}

.applicant-status-section .right-section {
    display: flex;
    gap: 10px;
}

.applicant-status-section .right-section button {
    padding: 10px 15px;
    font-size: 16px;
    font-weight: bold;
    border: none;
    background-color: #124A5C;
    color: white;
    border-radius: 4px;
    cursor: pointer;
    transition: background-color 0.3s ease;
}

.applicant-status-section .right-section button:hover {
    background-color: #B4E3E3;
    color: #124A5C;
}

/* Improved divider styles */
.applicant-status-section .divider {
    height: 2px;
    background-color: #124A5C;
    margin: 15px 0;
    width: 100%;
    display: block;
    clear: both;
}
/* Filter button styling */
.filter-button {
    padding: 10px 15px;
    font-size: 15px;
    font-weight: bold;
    border: none;
    background-color: #124A5C;
    color: white;
    border-radius: 4px;
    cursor: pointer;
    transition: background-color 0.3s ease;
    min-width: 130px;
}

.filter-button:hover {
    background-color: #0d3a47;
}

.filter-button.active {
    background-color: #07ACB9;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
}

/* Make buttons in last column more prominent */
.btn-review, 
.btn-evaluation, 
.btn-onboarding, 
.btn-approve {
    background-color: white;
    color: #124A5C;
    border: 1px solid #124A5C;
    padding: 8px 15px;
    cursor: pointer;
    border-radius: 5px;
    font-size: 14px;
    font-weight: bold;
    transition: background-color 0.3s ease, color 0.3s ease;
    min-width: 120px;
    display: inline-block;
    text-align: center;
    margin-top: 5px;
}

.btn-review:hover, 
.btn-evaluation:hover, 
.btn-onboarding:hover, 
.btn-approve:hover {
    background-color: #124A5C;
    color: white;
}

/* Improved table styles */
.tracking-table {
    width: 100%;
    border-collapse: collapse;
    margin-bottom: 20px;
    box-shadow: 0 1px 3px rgba(0,0,0,0.1);
}

.tracking-table th {
    background-color: #f5f5f5;
    color: #124A5C;
    font-weight: bold;
    padding: 12px 10px;
    border: 1px solid #ddd;
    text-align: left;
}

.tracking-table td {
    padding: 12px 10px;
    border: 1px solid #ddd;
    vertical-align: middle;
}

/* Better positioning of buttons in the last column */
.tracking-table td:last-child {
    position: relative;
}

.tracking-table td:last-child span {
    display: block;
    margin-bottom: 10px;
}

.tracking-table td:last-child div {
    text-align: right;
}

/* Sort section styling */
.sort-section {
    display: flex;
    align-items: center;
    margin: 10px 0;
}

.sort-section label {
    margin-right: 10px;
    font-weight: bold;
}

.sort-section select {
    padding: 8px;
    border: 1px solid #ddd;
    border-radius: 4px;
    background-color: white;
    min-width: 180px;
}

/* Additional Helper Classes */
.text-center {
    text-align: center;
}

.mt-10 {
    margin-top: 10px;
}

.mb-10 {
    margin-bottom: 10px;
}

/* Responsive adjustments */
@media (max-width: 1200px) {
    .main-content {
        margin-left: 250px;
        width: calc(100% - 250px);
    }
    
    .set-interview-button {
        width: 30%;
    }
}

@media (max-width: 768px) {
    .main-content {
        margin-left: 0;
        width: 100%;
    }
    
    .filter-section {
        flex-direction: column;
    }
    
    .search-bar {
        width: 100%;
    }
    
    .modal-content, .review-modal-content {
        width: 90%;
    }
    
    .set-interview-button {
        width: 100%;
    }

    .btn-toggle-status {
        padding: 6px 12px;
        background-color: #6c757d;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        transition: background-color 0.3s;
    }
    
    .btn-toggle-status:hover {
        background-color: #5a6268;
    }
    .btn-toggle-status.status-passed {
    background-color: #28a745;
}

.btn-toggle-status.status-failed {
    background-color: #dc3545;
}

/* Styling for no data message */
.no-data-message {
    padding: 20px;
    background-color: #f8f9fa;
    border-left: 4px solid #07ACB9;
    color: #555;
    font-size: 16px;
    font-style: italic;
}
.no-data-message p {
    margin: 0;
}

/* Improved table empty state */
table.tracking-table tbody:empty::after {
    content: "No data available";
    display: block;
    text-align: center;
    padding: 20px;
    color: #6c757d;
    font-style: italic;
}

/* Score cell coloring */
td.high-score {
    color: green !important;
    font-weight: bold;
}

td.medium-score {
    color: blue !important;
}

td.low-score {
    color: orange !important;
}

/* Styling for no data message */
.no-data-message {
    padding: 20px;
    background-color: #f8f9fa;
    border-left: 4px solid #07ACB9;
    color: #555;
    font-size: 16px;
    font-style: italic;
}
.no-data-message p {
    margin: 0;
}


/* Improved table empty state */
table.tracking-table tbody:empty::after {
    content: "No data available";
    display: block;
    text-align: center;
    padding: 20px;
    color: #6c757d;
    font-style: italic;
}
}

.btn-change-status {
    background-color: #dc3545;
    color: white;
    border: 1px solid #c82333;
    padding: 10px 20px;
    cursor: pointer;
    border-radius: 5px;
    font-size: 14px;
    transition: background-color 0.3s ease, color 0.3s ease;
    min-width: 150px;
    text-align: center;
    margin-top: 5px;
}

.btn-change-status:hover {
    background-color: #bd2130;
    color: white;
}
    </style>
</head>
<body>

<%- include('../../partials/linemanager_partials') %>

<!-- Main Content Section -->
<div class="main-content">

    <!-- Header Section -->
    <div class="header-section">
        <h2>Applicant Tracking</h2>
        <% if (applicants && applicants.length > 0) { %>
          <div class="subheader">
            <%= applicants[0].jobTitle %>
          </div>
        <% } else { %>
          <p>No applicant found.</p>
        <% } %>
    </div>
      
    <!-- Filter Buttons Section -->
    <div class="filter-section">
        <div class="right-section">
            <button id="filter-all" class="filter-button active">All</button>
            <button id="filter-forreview" class="filter-button">For Review</button>
            <button id="filter-forevaluation" class="filter-button">For Evaluation</button>
            <button id="filter-foronboarding" class="filter-button">For Onboarding</button>
        </div>
        <div class="search-container">
            <input type="text" id="searchBar" class="search-bar" placeholder="Search...">
            <button class="search-button">Search</button>
        </div>
    </div>


    <!-- Updated Applicant Status Section with fixed header layout and divider -->
<div class="applicant-status-section" id="applicantStatusSection">
    <!-- Header section with flexbox -->
    <div class="section-header">
        <h3 class="subheader">List of Applicants on <span id="currentPhase">Review</span></h3>
        <div class="right-section">
            <button id="notifyAllApplicants">Notify All Applicants</button>
        </div>
    </div>
    <!-- Divider placed immediately after the section-header -->
    <div class="divider"></div>
    
    <h4>Awaiting for Action</h4>
    <table class="tracking-table" id="awaitingActionTable">
        <thead>
            <tr>
                <th>Applicant No.</th>
                <th>Last Name, First Name</th>
                <th>Department</th>
                <th>Position Applied</th>
                <th>Total Score</th>
                <th>Applicant Status</th>
            </tr>
        </thead>
        <tbody>
            <!-- Will be populated dynamically -->
        </tbody>
    </table>

    <h4>Applicants on <span id="currentPhase">Review</span> Declared Results</h4>
    <div class="sort-section">
        <label for="sortOptions">Sort By:</label>
        <select id="sortOptions">
            <option value="ascending">Ranking - Ascending</option>
            <option value="descending">Ranking - Descending</option>
            <option value="alphabetical">Alphabetically</option>
        </select>
    </div>
    <table class="tracking-table" id="declaredResultsTable">
        <thead>
            <tr>
                <th>Applicant No.</th>
                <th>Last Name, First Name</th>
                <th>Department</th>
                <th>Position Applied</th>
                <th>Total Score</th>
                <th>Applicant Status</th>
            </tr>
        </thead>
        <tbody>
            <!-- Will be populated dynamically -->
        </tbody>
    </table>
    <!-- Job Offer Sent section will be created dynamically when needed -->
</div>

    <!-- Table for Applicant Data (shown by default) -->
    <table class="tracking-table" id="mainApplicantTable" style="width: 100%; margin-bottom: 20px; border-collapse: collapse;">
        <thead>
            <tr>
                <th>Applicant No.</th>
                <th>Last Name, First Name</th>
                <th>Department</th>
                <th>Position Applied</th>
                <th>Applicant Status & Actions</th>
            </tr>
        </thead>
        <tbody>
            <% if (applicants && applicants.length) { %>
                <% applicants.forEach((applicant, index) => { %>
                    <tr class="applicant-row" 
                        data-phase="<%= applicant.applicantStatus.startsWith('P1') ? 'P1' : applicant.applicantStatus.startsWith('P2') ? 'P2' : applicant.applicantStatus.startsWith('P3') ? 'P3' : 'other' %>" 
                        data-status="<%= applicant.applicantStatus %>"
                        data-userid="<%= applicant.userId %>"
                        data-name="<%= applicant.lastName %>, <%= applicant.firstName %>"
                        data-score="<%= applicant.initialScreeningAssessment && applicant.initialScreeningAssessment.totalScore !== 'N/A' ? applicant.initialScreeningAssessment.totalScore : '' %>">
                        <td><%= index + 1 %></td>
                        <td>
                            <%= applicant.lastName %>, <%= applicant.firstName %>
                            <br>
                            <small style="color: #555;"><%= applicant.userEmail || 'Email not available' %></small>
                        </td>
                        
                        <td><%= applicant.deptName %></td> <!-- Display department name -->
                        <td><%= applicant.jobTitle %></td> <!-- Display job title -->
                        <td>
                             <!-- Display Applicant Status -->
    <span><strong>Status:</strong> <%= applicant.applicantStatus || 'Pending' %></span>
    <div style="margin-top: 10px;">
        <% if (applicant.applicantStatus.startsWith('P1 - Awaiting for Line Manager Action; HR PASSED')) { %>
            <!-- For Review Button -->
            <button 
                class="btn-review" 
                onclick="lineManagerInitialScreeningModal(
                        '<%= applicant.userId %>', 
                        '<%= applicant.lastName %>', 
                        '<%= applicant.firstName %>', 
                        '<%= applicant.birthDate %>', 
                        '<%= applicant.userEmail %>', 
                        '<%= applicant.phoneNo %>', 
                        {
                            degree: '<%= applicant.initialScreeningAssessment.degreeScore %>',
                            experience: '<%= applicant.initialScreeningAssessment.experienceScore %>',
                            certifications: '<%= applicant.initialScreeningAssessment.certificationScore %>',
                            hardSkills: '<%= applicant.initialScreeningAssessment.hardSkillsScore %>',
                            softSkills: '<%= applicant.initialScreeningAssessment.softSkillsScore %>',
                            workSetup: '<%= applicant.initialScreeningAssessment.workSetupScore %>',
                            availability: '<%= applicant.initialScreeningAssessment.availabilityScore %>'
                        }, 
                        '<%= applicant.initialScreeningAssessment.totalScore %>', 
                        '<%= applicant.initialScreeningAssessment.degree_url %>',
                        '<%= applicant.initialScreeningAssessment.cert_url %>',
                        '<%= applicant.initialScreeningAssessment.resume_url %>'
                    )
                ">
                For Review
            </button>
        <% } else if (applicant.applicantStatus === 'P2 - Awaiting for HR Evaluation') { %>
            <!-- For Evaluation Button -->
            <a href="/hr/evaluation-form/<%= applicant.applicantId %>">
                <button class="btn-evaluation">For Evaluation</button>
            </a>
        <% } else if (applicant.applicantStatus.startsWith('P1 - Awaiting for Line Manager Action')) { %>
            <!-- Approve Button for Line Manager Action -->
            <button 
                class="btn-approve" 
                onclick="approveLineManager('<%= applicant.applicantId %>')">
                Approve
            </button>
        <% } else if (applicant.applicantStatus === 'P3 - Awaiting for Line Manager Evaluation') { %>
            <!-- For Evaluation Button -->
            <a href="/interview-form/<%= applicant.applicantId %>">
                <button class="btn-evaluation">For Evaluation</button>
            </a>
        <% } else if (applicant.applicantStatus === 'P3 - Line Manager Evaluation Accomplished') { %>
            <!-- View, Pass, Reject buttons for completed evaluations -->
            <a href="/view-interview-form/<%= applicant.applicantId %>">
                <button class="btn-review" style="margin-bottom: 5px;">View Evaluation</button>
            </a>
            <div style="display: flex; gap: 5px;">
                <button 
                    class="btn-approve" 
                    style="flex: 1; background-color: #28a745; color: white;"
                    onclick="p3passApplicant('<%= applicant.applicantId %>')">
                    Pass
                </button>
                <button 
                    class="btn-change-status" 
                    style="flex: 1; background-color: #dc3545; color: white;"
                    onclick="p3rejectApplicant('<%= applicant.applicantId %>')">
                    Reject
                </button>
            </div>

            
        <% } %>
    </div>
</td>   
                    </tr>
                <% }); %>
            <% } else { %>
                <tr>
                    <td colspan="5">No applicants found.</td>
                </tr>
            <% } %>
        </tbody>
    </table>

    <h2 class="header-section" id="onboardingHeader" style="margin-top: 30px; margin-bottom: 10px;">Onboarding</h2>

    <table class="tracking-table" id="onboardingTable" style="width: 100%; border-collapse: collapse;">
        <thead>
            <tr>
                <th>Application No.</th>
                <th>Last Name, First Name</th>
                <th>Department</th>
                <th>Position Applied</th>
                <th>Application Status & Actions</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>APP00018</td>
                <td>William Scott<br>williamscott@gmail.com</td>
                <td>IT</td>
                <td>Data Analyst</td>
                <td>First Day Checklist Sent</td>
            </tr>
            <tr class="status-for-onboarding">
                <td>APP00019</td>
                <td>Grace Taylor<br>gracetaylor@gmail.com</td>
                <td>IT</td>
                <td>Data Analyst</td>
                <td>Checklist Accomplished <button class="btn-onboarding" onclick="openModal('accountSetupReminderModal')">For Onboarding</button></td>
            </tr>
            <tr>
                <td>APP00020</td>
                <td>Ella Martinez<br>ellamartinez@gmail.com</td>
                <td>IT</td>
                <td>Data Analyst</td>
                <td>Account Created</td>
            </tr>
        </tbody>
    </table>

    <button class="set-interview-button" onclick="setInterviewAvailabilities()">Set Interview Availabilities on Calendly</button>

    <!-- Modal for notifying applicants -->
<!-- Modal for finalizing review and notifying applicants -->
<div id="notifyApplicantsModal" class="modal">
    <div class="modal-content">
        <span class="close-button" onclick="closeModal('notifyApplicantsModal')">&times;</span>
        <h2>Confirm Finalization</h2>
        <p>You are about to finalize the review process and notify all applicants who were not selected that they have not advanced to the next stage. This action is irreversible. Are you sure you want to proceed?</p>
        <div class="modal-buttons">
            <button id="backButton" class="back-button" onclick="closeModal('notifyApplicantsModal')">Back</button>
            <button id="confirmButton" class="confirm-button">Confirm</button>
        </div>
    </div>
</div>
    <!-- Modal for P1: Finalize Review and Notify Applicants -->
    <div id="finalizeModalP1" class="modal">
        <div class="modal-content">
            <span class="close-button">&times;</span>
            <h2>Confirm Final Review and Notify Applicants</h2>
            <p>You are about to finalize the review process and notify all applicants who were not selected that they have not advanced to the next stage. This action is irreversible. Are you sure you want to proceed?</p>
            <div class="modal-buttons">
                <button id="backButtonP1" class="back-button">Back</button>
                <button id="confirmButtonP1" class="confirm-button">Confirm</button>
            </div>
        </div>
    </div>

    <!-- P1 - Line Manager Review Modal -->
    <div id="lineManagerInitialScreeningModalHtml" class="review-modal">
        <div class="review-modal-content">
            <span class="review-close-button">&times;</span>
            <h2>P1: Initial Screening Score Breakdown</h2> 
            <div class="divider"></div>
            <div class="applicant-details">
                <input type="hidden" id="userId">
                <input type="hidden" id="jobId">            
                <input type="hidden" id="applicantId">

                <p><strong>Name:</strong> <span id="applicant-name"></span></p>
                <p><strong>Birthday:</strong> <span id="applicant-birthday"></span></p>
                <p><strong>Email:</strong> <span id="applicant-email"></span></p>
                <p><strong>Contact No.:</strong> <span id="applicant-contact"></span></p>
            </div>

            <h4>HR Online Assessment Form Breakdown</h4>
            <h4>Initial Screening Scores</h4> 

            <table class="scores-table"> 
                <thead> 
                    <tr> 
                        <th>Criteria</th> 
                        <th>Score</th> 
                    </tr> 
                </thead> 
                <tbody> 
                    <tr> 
                        <td>Industry Specific Degree</td> 
                        <td id="score-degree"></td> 
                    </tr> 
                    <tr> 
                        <td>Experiences</td> 
                        <td id="score-experience"></td> 
                    </tr> 
                    <tr> 
                        <td>Certifications</td> 
                        <td id="score-certifications"></td> 
                    </tr> 
                    <tr> 
                        <td>Hard Skills</td> 
                        <td id="score-hard-skills"></td> 
                    </tr> 
                    <tr> 
                        <td>Soft Skills</td> 
                        <td id="score-soft-skills"></td> 
                    </tr> 
                    <tr> 
                        <td>Work Setup</td> 
                        <td id="score-work-setup"></td> 
                    </tr> 
                    <tr> 
                        <td>Availability</td> 
                        <td id="score-availability"></td> 
                    </tr> 
                </tbody> 
            </table> 

            <div class="computation-verdict"> 
                <strong>Computation Verdict - <span id="computation-verdict"></span></strong> 
            </div> 

            <h4>Uploaded Documents</h4>
            <p><strong>Degree:</strong> <a id="degree-doc" href="#" target="_blank">No document uploaded</a></p>
            <div id="degree-preview" style="margin-top: 10px;"></div>
            
            <p><strong>Certification:</strong> <a id="cert-doc" href="#" target="_blank">No document uploaded</a></p>
            <div id="cert-preview" style="margin-top: 10px;"></div>
            
            <p><strong>Resume:</strong> <a id="resume-doc" href="#" target="_blank">No document uploaded</a></p>
            <div id="resume-preview" style="margin-top: 10px;"></div>
            
            
            <h4>Decision</h4>
            <p>
                <strong>Would you like to pass or reject this applicant for the HR interview?</strong>
            </p>

            <div class="decision-disclaimer">
                <p>üí° <strong>Important:</strong> Pressing <strong>"Pass"</strong> will mark the applicant as likely to proceed to the HR interview stage, but this decision can still be changed before finalizing. Likewise, pressing <strong>"Reject"</strong> will mark the applicant as failed, but this can also be modified until the finalization step.</p>
                <p>‚ö†Ô∏è <strong>Finalization Note:</strong> Once you press "Finalize," all passed and failed applicants will be officially informed of their status. Please double-check before proceeding.</p>
            </div>

            <div class="review-modal-buttons">
                <button id="backButton" class="review-modal-back-button">Back</button>
                <button id="rejectButton" class="review-modal-reject-button" onclick="rejectApplicant()">Reject</button>
                <button id="passButton" class="review-modal-pass-button" onclick="passApplicant()">Pass</button>
            </div>
        </div>
    </div>

    <!-- Modal for P2: Finalize Review and Notify Applicants -->
    <div id="finalizeModalP2" class="modal">
        <div class="modal-content">
            <span class="close-button">&times;</span>
            <h2>Confirm Final Review and Notify Applicants</h2>
            <p>You are about to finalize the review process and notify all applicants who were not selected that they have not advanced to the next stage. This action is irreversible. Are you sure you want to proceed?</p>
            <div class="modal-buttons">
                <button id="backButtonP2" class="back-button">Back</button>
                <button id="confirmButtonP2" class="confirm-button">Confirm</button>
            </div>
        </div>
    </div>

    <!-- Modal for P3: Finalize Review and Notify Applicants -->
    <div id="finalizeModalP3" class="modal">
        <div class="modal-content">
            <span class="close-button">&times;</span>
            <h2>Confirm Final Review and Notify Applicants</h2>
            <p>You are about to finalize the review process and notify all applicants who were not selected that they have not advanced to the next stage. This action is irreversible. Are you sure you want to proceed?</p>
            <div class="modal-buttons">
                <button id="backButtonP3" class="back-button">Back</button>
                <button id="confirmButtonP3" class="confirm-button">Confirm</button>
            </div>
        </div>
    </div>

    <!-- Other modals for account setup, job offers, etc. -->
    <div id="releaseJobOfferModal" class="modal">
        <div class="modal-content">
            <span class="close-button" onclick="closeModal('releaseJobOfferModal')">&times;</span>
            <h2 style="color: #07ACB9;" id="applicant-name-job-offer">Name</h2>
            <p><strong>Age:</strong> <span id="applicant-age-job-offer">Text</span></p>
            <p><strong>Email:</strong> <span id="applicant-email-job-offer">Text</span></p>
            <p><strong>Contact No:</strong> <span id="applicant-contact-job-offer">Text</span></p>
            
            <div class="divider"></div>
            
            <h3>Panel Assessment Form Breakdown</h3>
            <p>[INSERT SUBMITTED FORM HERE]</p>
            
            <div class="modal-question">
                <p><strong>Would you like to release the job offer and notify the applicant they are being considered for hiring?</strong></p>
            </div>
            
            <div class="modal-buttons">
                <button id="backButton" onclick="closeModal('releaseJobOfferModal')">Back</button>
                <button id="confirmButton" onclick="sendNotification()">Notify Applicant</button>
            </div>
        </div>
    </div>

    <!-- Modal for Moving Applicant for Onboarding -->
    <div id="moveToOnboardingModal" class="modal">
        <div class="modal-content">
            <span class="close-button" onclick="closeModal('moveToOnboardingModal')">&times;</span>
            <h1>Job Offer Confirmation</h1>
            
            <h2><strong>Applicant Personal Information</strong></h2>
            <h3><strong id="applicant-name-onboarding">Name</strong></h3>
            <p><strong>Age:</strong> <span id="applicant-age-onboarding">Text</span></p>
            <p><strong>Email:</strong> <span id="applicant-email-onboarding">Text</span></p>
            <p><strong>Contact No:</strong> <span id="applicant-contact-onboarding">Text</span></p>
            
            <div class="modal-question">
                <p><strong>Would you like to move this applicant for onboarding?</strong></p>
            </div>
            
            <div class="modal-buttons">
                <button id="backButton" onclick="closeModal('moveToOnboardingModal')">Back</button>
                <button id="confirmButton" onclick="confirmOnboarding()">Confirm</button>
            </div>
        </div>
    </div>

    <!-- Modal for Account Setup Creation Reminder -->
    <div id="accountSetupReminderModal" class="modal">
        <div class="modal-content">
            <span class="close-button" onclick="closeModal('accountSetupReminderModal')">&times;</span>
            <h1>Account Setup Creation Reminder</h1>
            
            <h2><strong>Applicant Personal Information</strong></h2>
            <h3><strong id="applicant-name-account">Name</strong></h3>
            <p><strong>Age:</strong> <span id="applicant-age-account">Text</span></p>
            <p><strong>Email:</strong> <span id="applicant-email-account">Text</span></p>
            <p><strong>Contact No:</strong> <span id="applicant-contact-account">Text</span></p>
            
            <div class="modal-question">
                <p><strong>Have you created an account for the employee through the Manage Employees page and emailed them the account details?</strong></p>
            </div>
            
            <div class="modal-buttons">
                <button id="backButton" onclick="closeModal('accountSetupReminderModal')">Back</button>
                <button id="confirmButton" onclick="confirmAccountSetup()">Confirm</button>
            </div>
        </div>
    </div>
</div>

<!-- Add this right after the head tag, before any scripts -->
<script id="applicants-data" type="application/json">
    <% if (typeof applicants !== 'undefined') { %>
      <%- JSON.stringify(applicants) %>
    <% } else { %>
      []
    <% } %>
    </script>

<script>
  document.addEventListener("DOMContentLoaded", function () {
    const evaluationButtons = document.querySelectorAll(".btn-evaluation");

    evaluationButtons.forEach(button => {
        button.addEventListener("click", function () {
            window.location.href = "/linemanager/interview-form";
        });
    });
});
document.addEventListener("DOMContentLoaded", function() {
  // Initialize global data structures
  window.allUserIds = [];
  window.applicantsScores = {};
  window.applicantNameMapping = {};
  window.nameToUserId = {};
  window.emailToUserId = {};
  window.displayNameToUserId = {};
  window.applicantRegistry = {}; // New registry for centralized data management
  window.mainTableScores = {}; // New mapping for scores from main table
  window.mainTableUserIds = {}; // New mapping for userIds from main table
  window.applicantStatusMap = {}; // New mapping for applicant statuses
  window.applicantsData = []; // For storing API data

  // NEW FUNCTION: Load applicants data from embedded script
  function loadApplicantsData() {
    try {
      const dataScript = document.getElementById('applicants-data');
      if (dataScript) {
        window.applicantsData = JSON.parse(dataScript.textContent);
        console.log(`Loaded ${window.applicantsData.length} applicants from embedded data`);
        
        // Create mappings of userIds, names, and scores
        window.applicantsData.forEach(applicant => {
          if (applicant.userId) {
            // Store name to userId mapping
            const fullName = `${applicant.lastName}, ${applicant.firstName}`;
            window.applicantNameMapping[fullName] = applicant.userId;
            window.nameToUserId[fullName] = applicant.userId;
            window.mainTableUserIds[fullName] = applicant.userId;
            
            // Store score if available
            if (applicant.initialScreeningAssessment && 
                applicant.initialScreeningAssessment.totalScore !== 'N/A') {
              window.applicantsScores[applicant.userId] = applicant.initialScreeningAssessment.totalScore;
              window.mainTableScores[fullName] = applicant.initialScreeningAssessment.totalScore;
              window.mainTableScores[applicant.userId] = applicant.initialScreeningAssessment.totalScore;
            }

            // Store in registry for comprehensive lookup
            window.applicantRegistry[applicant.userId] = {
              userId: applicant.userId,
              fullName: fullName,
              email: applicant.userEmail || '',
              department: applicant.deptName || '',
              position: applicant.jobTitle || '',
              status: applicant.applicantStatus || '',
              score: applicant.initialScreeningAssessment?.totalScore || 'N/A'
            };
          }
        });
        
        return true;
      }
    } catch (error) {
      console.error("Error loading applicants data:", error);
    }
    return false;
  }

  // NEW FUNCTION: Ensure all elements have userId attributes
  function ensureUserIdAttributes() {
    console.log("Ensuring userId attributes are set on all rows and buttons...");
    
    // Extract userIds from review buttons
    const reviewButtons = document.querySelectorAll('.btn-review[onclick*="lineManagerInitialScreeningModal"]');
    console.log(`Found ${reviewButtons.length} review buttons to extract userIds from`);
    
    reviewButtons.forEach(button => {
      const onclick = button.getAttribute('onclick') || '';
      const match = onclick.match(/lineManagerInitialScreeningModal\s*\(\s*['"]([^'"]*)['"]/);
      
      if (match && match[1]) {
        const userId = match[1];
        const row = button.closest('tr');
        
        if (row) {
          // Set userId on row
          row.setAttribute('data-userid', userId);
          
          // Set userId on button if not already set
          if (!button.getAttribute('data-userid')) {
            button.setAttribute('data-userid', userId);
          }
          
          // Extract name for mapping
          const nameCell = row.querySelector('td:nth-child(2)');
          if (nameCell) {
            const fullName = nameCell.textContent.split('\n')[0].trim();
            
            // Save mapping for future lookups
            window.nameToUserId[fullName] = userId;
            window.applicantNameMapping[fullName] = userId;
            window.mainTableUserIds[fullName] = userId;
            
            console.log(`Mapped name "${fullName}" to userId ${userId}`);
            
            // Extract score if available
            const scoreMatch = onclick.match(/},\s*['"]([^'"]*)['"]/);
            if (scoreMatch && scoreMatch[1]) {
              const score = scoreMatch[1];
              
              // Cache score in various places for compatibility
              window.applicantsScores[userId] = score;
              window.mainTableScores[userId] = score;
              window.mainTableScores[fullName] = score;
              
              // Add score to row data attribute
              row.setAttribute('data-score', score);
              
              console.log(`Mapped score ${score} to userId ${userId}`);
            }
          }
        }
      }
    });
    
    // Fix change status buttons
    const changeButtons = document.querySelectorAll('.btn-change-status');
    console.log(`Found ${changeButtons.length} change status buttons to fix`);
    
    changeButtons.forEach((button, index) => {
      // Get userId from button or parent row
      let userId = button.getAttribute('data-userid');
      
      if (!userId || userId === 'undefined' || userId === '') {
        const row = button.closest('tr');
        if (row) {
          userId = row.getAttribute('data-userid');
          
          if (userId && userId !== 'undefined' && userId !== '') {
            // Set userId on button
            button.setAttribute('data-userid', userId);
            button.setAttribute('onclick', `changeApplicantStatus('${userId}')`);
            console.log(`Fixed change status button ${index} with userId ${userId}`);
          } else {
            // Try to find userId by name
            const nameCell = row.querySelector('td:nth-child(2)');
            if (nameCell) {
              const fullName = nameCell.textContent.split('\n')[0].trim();
              
              if (window.nameToUserId[fullName]) {
                userId = window.nameToUserId[fullName];
                
                // Set userId on row and button
                row.setAttribute('data-userid', userId);
                button.setAttribute('data-userid', userId);
                button.setAttribute('onclick', `changeApplicantStatus('${userId}')`);
                
                console.log(`Fixed change status button ${index} with userId ${userId} from name "${fullName}"`);
              }
            }
          }
        }
      }
    });
    
    // Fix toggle status buttons
    const toggleButtons = document.querySelectorAll('.btn-toggle-status');
    console.log(`Found ${toggleButtons.length} toggle status buttons to fix`);
    
    toggleButtons.forEach((button, index) => {
      // Get userId from button or parent row
      let userId = button.getAttribute('data-userid');
      
      if (!userId || userId === 'undefined' || userId === '') {
        const row = button.closest('tr');
        if (row) {
          userId = row.getAttribute('data-userid');
          
          if (userId && userId !== 'undefined' && userId !== '') {
            // Set userId on button
            button.setAttribute('data-userid', userId);
            console.log(`Fixed toggle status button ${index} with userId ${userId}`);
          }
        }
      }
    });
  }

  // Load data and ensure userIds are set
  loadApplicantsData();
  ensureUserIdAttributes();
  
  // Next, call your existing initialization functions
  
  // Look for applicants data in the rendered page (fallback method)
  try {
    if (!window.applicantsData.length) {
      const applicantsDataElement = document.getElementById('applicants-data');
      if (applicantsDataElement) {
        window.applicantsData = JSON.parse(applicantsDataElement.textContent);
        console.log(`Loaded ${window.applicantsData.length} applicants from API data`);
        
        // Pre-populate scores from API data
        window.applicantsData.forEach(applicant => {
          if (applicant.userId && applicant.initialScreeningAssessment && 
              applicant.initialScreeningAssessment.totalScore !== 'N/A') {
            window.applicantsScores[applicant.userId] = applicant.initialScreeningAssessment.totalScore;
            
            // Also map by name if available
            if (applicant.firstName && applicant.lastName) {
              const fullName = `${applicant.lastName}, ${applicant.firstName}`;
              window.mainTableScores[fullName] = applicant.initialScreeningAssessment.totalScore;
            }
          }
        });
      }
    }
  } catch (error) {
    console.error('Error parsing applicants data:', error);
  }
  
  // Initial data extraction - these functions can stay as they are
  if (typeof extractScoresFromMainTable === 'function') {
    extractScoresFromMainTable();
  }
  
  if (typeof buildApplicantRegistry === 'function') {
    buildApplicantRegistry();
  }
  
  if (typeof scanAllRowsForUserIds === 'function') {
    scanAllRowsForUserIds();
  }
  
  if (typeof manuallyExtractUserIdsAndScores === 'function') {
    manuallyExtractUserIdsAndScores();
  }
  
  captureInitialScreeningScores();
  captureApplicantsDataEnhanced();
  
  // If there's no API data, try to extract the data from the table rows
  if (!window.applicantsData.length && typeof extractApplicantsDataFromDOM === 'function') {
    extractApplicantsDataFromDOM();
  }
  
  // Set up event listeners
  setupEventListeners();
  
  // Ensure proper initialization of UI elements
  ensureTableHeaders();
  fixHeaderStructure();
  
  // Close modal when the close button is clicked
  const closeButton = document.querySelector('.review-close-button');
  if (closeButton) {
    closeButton.addEventListener('click', function () {
      document.getElementById('lineManagerInitialScreeningModalHtml').style.display = 'none';
    });
  }
  
  // Close modal if clicked outside the modal content
  window.addEventListener('click', function (event) {
    const modal = document.getElementById('lineManagerInitialScreeningModalHtml');
    if (event.target === modal) {
      modal.style.display = 'none';
    }
  });
  
  // Sequence of operations with timeouts to ensure everything loads properly
  initializeWithTimeouts();
  
  // Add these lines at the end of your DOMContentLoaded event handler
  setTimeout(debugUserIdExtraction, 1000);
  setTimeout(lastResortUserIdAssignment, 2500);
});

// Function to extract applicant data from hidden JSON
function extractApplicantDataFromScript() {
  console.log("Extracting applicant data from embedded script...");
  
  // Create a hidden script element with the applicants data as JSON
  // This is a fallback way to expose the data to the client
  const dataScript = document.createElement('script');
  dataScript.id = 'applicants-data-script';
  dataScript.type = 'application/json';
  
  // Get applicants data from the current context
  // This assumes the 'applicants' variable is available in the page scope
  try {
    if (typeof applicants !== 'undefined') {
      dataScript.textContent = JSON.stringify(applicants);
      document.head.appendChild(dataScript);
      console.log("Added applicants data script to the page");
    } else {
      console.log("No 'applicants' variable found in scope");
    }
  } catch (err) {
    console.error("Error adding applicants data script:", err);
  }
  
  // Try to read the data from any existing script
  const existingDataScript = document.getElementById('applicants-data-script') || 
                           document.querySelector('script[type="application/json"]');
  
  if (existingDataScript) {
    try {
      const extractedData = JSON.parse(existingDataScript.textContent);
      console.log(`Extracted ${extractedData.length} applicants from script`);
      
      // Store the data in the window object for access by other functions
      window.applicantsData = extractedData;
      
      // Create userId and score mappings
      window.applicantsScores = {};
      window.applicantNameMapping = {};
      
      extractedData.forEach(applicant => {
        if (applicant.userId) {
          // Create name mapping
          const fullName = `${applicant.lastName}, ${applicant.firstName}`;
          window.applicantNameMapping[fullName] = applicant.userId;
          
          // Create score mapping
          if (applicant.initialScreeningAssessment && 
              applicant.initialScreeningAssessment.totalScore !== 'N/A') {
            window.applicantsScores[applicant.userId] = applicant.initialScreeningAssessment.totalScore;
          }
        }
      });
      
      return extractedData.length;
    } catch (err) {
      console.error("Error parsing applicants data script:", err);
    }
  }
  
  return 0;
}


// Modified initialization with timeouts to include our new functions
function initializeWithTimeouts() {
  setTimeout(() => {
    // First show all data
    filterRowsByStatus("all");
    
    // Extract scores from main table again after it's visible
    if (typeof extractScoresFromMainTable === 'function') {
      setTimeout(extractScoresFromMainTable, 300);
    }
    
    // Fix scores in all tables
    setTimeout(fixAllTableScores, 500);
    
    // Set up toggle status buttons
    setTimeout(setupToggleStatusButtons, 700);
    
    // Rebuild the registry after tables are populated to ensure all data is captured
    if (typeof buildApplicantRegistry === 'function') {
      setTimeout(buildApplicantRegistry, 800);
    }
    
    // Then run our direct fixes for rows and buttons
    if (typeof rebuildAllTableRows === 'function') {
      setTimeout(rebuildAllTableRows, 900);
    }
    
    // Force another scan to catch any missed userIds
    if (typeof scanAllRowsForUserIds === 'function') {
      setTimeout(scanAllRowsForUserIds, 1000);
    }
    
    // Fix all buttons using the registry approach
    if (typeof fixChangeStatusButtons === 'function') {
      setTimeout(fixChangeStatusButtons, 1200);
    }
    
    // Final emergency fix for any buttons still missing userIds
    setTimeout(emergencyButtonFix, 1500);
    
    // Final pass to fix any scores that might still be N/A
    setTimeout(() => {
      const declaredResultsTable = document.getElementById('declaredResultsTable');
      if (declaredResultsTable) {
        const rows = declaredResultsTable.querySelectorAll('tbody tr:not(.section-header-row)');
        rows.forEach(row => {
          if (row.querySelector('td[colspan]')) return;
          
          const scoreCell = row.querySelector('td:nth-child(5)');
          if (scoreCell && scoreCell.textContent.trim() === 'N/A') {
            const userId = row.getAttribute('data-userid');
            if (userId) {
              // Try to find a score from our various sources
              let score = null;
              
              // Check applicantsScores cache
              if (window.applicantsScores[userId]) {
                score = window.applicantsScores[userId];
              }
              // Check mainTableScores cache
              else if (window.mainTableScores[userId]) {
                score = window.mainTableScores[userId];
              }
              // Check API data
              else if (window.applicantsData.length) {
                const applicant = window.applicantsData.find(a => a.userId === userId);
                if (applicant && applicant.initialScreeningAssessment) {
                  score = applicant.initialScreeningAssessment.totalScore;
                }
              }
              
              // If we found a score, update the cell
              if (score && score !== 'N/A') {
                updateScoreCellWithFormatting(row, score);
              }
            }
          }
        });
      }
    }, 2000);
  }, 200);
}

function extractApplicantsDataFromDOM() {
  console.log("Extracting applicants data from DOM...");
  window.applicantsData = [];
  
  // Get all rows from the main table
  const mainTable = document.getElementById('mainApplicantTable');
  if (!mainTable) return;
  
  const rows = mainTable.querySelectorAll('tbody tr');
  
  rows.forEach((row, index) => {
    // Skip header rows
    if (row.classList.contains('section-header-row')) return;
    
    // Get userId from row or review button
    let userId = row.getAttribute('data-userid');
    if (!userId) {
      const reviewButton = row.querySelector('.btn-review');
      if (reviewButton) {
        const onclick = reviewButton.getAttribute('onclick') || '';
        const match = onclick.match(/lineManagerInitialScreeningModal\s*\(\s*['"]([^'"]*)['"]/);
        if (match && match[1]) {
          userId = match[1];
        }
      }
    }
    
    if (!userId) return;
    
    // Extract name, department, etc.
    const nameCell = row.querySelector('td:nth-child(2)');
    const deptCell = row.querySelector('td:nth-child(3)');
    const positionCell = row.querySelector('td:nth-child(4)');
    const scoreCell = row.querySelector('td:nth-child(5)');
    
    const name = nameCell ? nameCell.textContent.split('\n')[0].trim() : '';
    const department = deptCell ? deptCell.textContent.trim() : '';
    const position = positionCell ? positionCell.textContent.trim() : '';
    const score = scoreCell ? scoreCell.textContent.trim() : 'N/A';
    
    // Store the data
    window.applicantsData.push({
      userId,
      firstName: name.split(' ')[1] || '',
      lastName: name.split(' ')[0] || '',
      departmentName: department,
      jobTitle: position,
      initialScreeningAssessment: {
        totalScore: score
      }
    });
  });
  
  console.log(`Extracted ${window.applicantsData.length} applicants from DOM`);
}

// Setup event listeners for filter buttons, search, modals, etc.
function setupEventListeners() {
  // Get references to filter buttons
  const filterAllButton = document.getElementById("filter-all");
  const filterForReviewButton = document.getElementById("filter-forreview");
  const filterForEvaluationButton = document.getElementById("filter-forevaluation");
  const filterForOnboardingButton = document.getElementById("filter-foronboarding");
  
  // Get references to sections and tables
  const notifyAllButton = document.getElementById("notifyAllApplicants");
  const sortOptions = document.getElementById("sortOptions");
  
  // Add event listeners for filter buttons
  if (filterAllButton) filterAllButton.addEventListener("click", () => filterRowsByStatus("all"));
  if (filterForReviewButton) filterForReviewButton.addEventListener("click", () => filterRowsByStatus("forreview"));
  if (filterForEvaluationButton) filterForEvaluationButton.addEventListener("click", () => filterRowsByStatus("forevaluation"));
  if (filterForOnboardingButton) filterForOnboardingButton.addEventListener("click", () => filterRowsByStatus("foronboarding"));
  
  // Notify all applicants button functionality
  if (notifyAllButton) {
    notifyAllButton.addEventListener("click", function() {
      const currentPhase = document.querySelector("#currentPhase").textContent;
      
      if (checkAllApplicantsMarked()) {
        openModal('notifyApplicantsModal');
      } else {
        alert(`Not all applicants in ${currentPhase} have been marked as passed or failed. Please make a decision first.`);
      }
    });
  }
  
  // Sort options change event
  if (sortOptions) {
    sortOptions.addEventListener("change", function() {
      sortDeclaredResults(this.value);
    });
  }
  
  // Setup the search functionality
  const searchBar = document.getElementById("searchBar");
  const searchButton = document.querySelector(".search-button");
  
  if (searchBar && searchButton) {
    // Search button click event
    searchButton.addEventListener("click", filterTable);
    
    // Enter key press in search bar
    searchBar.addEventListener("keypress", function(e) {
      if (e.key === "Enter") {
        e.preventDefault();
        filterTable();
      }
    });
  }
  
  // Setup modal event listeners
  setupModalEventListeners();
}

// Initialize with timeouts to ensure proper loading sequence
function initializeWithTimeouts() {
  setTimeout(() => {
    // First show all data
    filterRowsByStatus("all");
    
    // Extract scores from main table again after it's visible
    if (typeof extractScoresFromMainTable === 'function') {
      setTimeout(extractScoresFromMainTable, 300);
    }
    
    // Fix scores in all tables
    setTimeout(fixAllTableScores, 500);
    
    // Set up toggle status buttons
    setTimeout(setupToggleStatusButtons, 700);
    
    // Rebuild the registry after tables are populated to ensure all data is captured
    if (typeof buildApplicantRegistry === 'function') {
      setTimeout(buildApplicantRegistry, 800);
    }
    
    // Then run our direct fixes for rows and buttons
    if (typeof rebuildAllTableRows === 'function') {
      setTimeout(rebuildAllTableRows, 900);
    }
    
    // Force another scan to catch any missed userIds
    if (typeof scanAllRowsForUserIds === 'function') {
      setTimeout(scanAllRowsForUserIds, 1000);
    }
    
    // Fix all buttons using the registry approach
    if (typeof fixAllChangeStatusButtons === 'function') {
      setTimeout(fixAllChangeStatusButtons, 1200);
    }
    
    // Final emergency fix for any buttons still missing userIds
    setTimeout(emergencyButtonFix, 1500);
  }, 200);
}

// Emergency fix for change status buttons
function emergencyButtonFix() {
  console.log("*** EMERGENCY FIX: Direct userId injection for Change Status buttons ***");
  
  // Get all Change Status buttons
  const buttons = document.querySelectorAll('.btn-change-status');
  console.log(`Found ${buttons.length} Change Status buttons for direct fix`);
  
  // Fix each button
  buttons.forEach((button, index) => {
    // Skip buttons that already have userId
    if (button.getAttribute('data-userid') && 
        button.getAttribute('data-userid') !== 'undefined' && 
        button.getAttribute('data-userid') !== '') {
      return;
    }
    
    // First try to get userId from row
    const row = button.closest('tr');
    let userId = row ? row.getAttribute('data-userid') : null;
    
    // If no userId, try from registry using getReliableUserId if available
    if ((!userId || userId === 'undefined' || userId === '') && typeof getReliableUserId === 'function') {
      userId = getReliableUserId(row);
    }
    
    // If still no userId, try from name cell with traditional methods
    if (!userId && row) {
      const nameCell = row.querySelector('td:nth-child(2)');
      if (nameCell) {
        const nameCellText = nameCell.textContent.trim();
        console.log(`Button ${index}: Row name cell text: "${nameCellText}"`);
        
        // Extract the first part (name) and match against the known mappings
        const nameParts = nameCellText.split('\n');
        if (nameParts.length > 0) {
          const name = nameParts[0].trim();
          console.log(`Button ${index}: Extracted name: "${name}"`);
          
          // Try our various mappings
          if (window.nameToUserId && window.nameToUserId[name]) {
            userId = window.nameToUserId[name];
          } else if (window.applicantNameMapping && window.applicantNameMapping[name]) {
            userId = window.applicantNameMapping[name];
          } else if (window.displayNameToUserId && window.displayNameToUserId[nameCellText]) {
            userId = window.displayNameToUserId[nameCellText];
          } 
          // Try the new mainTableUserIds mapping
          else if (window.mainTableUserIds && window.mainTableUserIds[name]) {
            userId = window.mainTableUserIds[name];
          }
          // Try registry directly as last resort for name matching
          else if (window.applicantRegistry) {
            for (const [id, data] of Object.entries(window.applicantRegistry)) {
              if (data.fullName === name) {
                userId = id;
                break;
              }
            }
          }
        }
      }
    }
    
    // If we've found a userId, update the button
    if (userId && userId !== 'undefined' && userId !== '') {
      button.setAttribute('data-userid', userId);
      button.setAttribute('onclick', `changeApplicantStatus('${userId}')`);
      console.log(`Button ${index}: DIRECT FIX APPLIED - Set userId to ${userId}`);
      
      // Also update the row if it exists
      if (row) {
        row.setAttribute('data-userid', userId);
      }
    } else {
      // Log the error but don't use any hardcoded fallback
      console.error(`Button ${index}: Could not find any valid userId - button may not work`);
      // Mark the button as disabled to prevent errors
      button.disabled = true;
      button.title = "Could not identify applicant - please refresh the page";
    }
  });
  
  // One final pass to fix any missing scores after userIds are corrected
  setTimeout(finalScoresFix, 200);
}

// Final fix for any remaining score issues
function finalScoresFix() {
  // Extract scores one more time
  if (typeof extractScoresFromMainTable === 'function') {
    extractScoresFromMainTable();
  }
  
  // Fix all table scores
  fixAllTableScores();
  
  // Apply a final fix to declared results table if any scores are still N/A
  const declaredResultsTable = document.getElementById('declaredResultsTable');
  if (declaredResultsTable) {
    const rows = declaredResultsTable.querySelectorAll('tbody tr:not(.section-header-row)');
    rows.forEach((row) => {
      if (row.querySelector('td[colspan]')) return;
      
      const nameCell = row.querySelector('td:nth-child(2)');
      const scoreCell = row.querySelector('td:nth-child(5)');
      
      if (nameCell && scoreCell && scoreCell.textContent.trim() === 'N/A') {
        const name = nameCell.textContent.split('\n')[0].trim();
        
        // Try getting score from mainTableScores by name
        if (window.mainTableScores && window.mainTableScores[name]) {
          const score = window.mainTableScores[name];
          scoreCell.innerHTML = `<span class="score">${score}</span>`;
          console.log(`Final fix: Applied score ${score} for row with name '${name}'`);
          
          // Add appropriate color
          applyScoreColor(scoreCell, score);
        }
        // If not found by name, try by userId
        else {
          const userId = row.getAttribute('data-userid');
          if (userId && window.mainTableScores && window.mainTableScores[userId]) {
            const score = window.mainTableScores[userId];
            scoreCell.innerHTML = `<span class="score">${score}</span>`;
            console.log(`Final fix: Applied score ${score} for row with userId ${userId}`);
            
            // Add appropriate color
            applyScoreColor(scoreCell, score);
          }
        }
      }
    });
  }
}

// Apply color to score cell based on value
function applyScoreColor(scoreCell, score) {
  const scoreValue = parseFloat(score);
  if (!isNaN(scoreValue)) {
    if (scoreValue >= 85) {
      scoreCell.classList.add('high-score');
      scoreCell.style.color = 'green';
    } else if (scoreValue >= 75) {
      scoreCell.classList.add('medium-score');
      scoreCell.style.color = 'blue';
    } else {
      scoreCell.classList.add('low-score');
      scoreCell.style.color = 'orange';
    }
  }
}

// ============================
// DATA EXTRACTION & MANAGEMENT
// ============================

// Extract scores from main table
function extractScoresFromMainTable() {
  console.log("Extracting scores and userIds from main table (All filter)...");
  
  // Initialize or reset the global score mapping
  window.mainTableScores = {};
  window.mainTableUserIds = {};
  
  // Get the main table
  const mainTable = document.getElementById('mainApplicantTable');
  if (!mainTable) {
    console.log("Main table not found");
    return;
  }
  
  // Get all rows from the main table
  const rows = mainTable.querySelectorAll('tbody tr');
  console.log(`Found ${rows.length} rows in main table`);
  
  // Process each row to extract userIds and scores
  rows.forEach((row, index) => {
    // Get the name, which we'll use as a key for mapping
    const nameCell = row.querySelector('td:nth-child(2)');
    if (!nameCell) return;
    
    const fullName = nameCell.textContent.split('\n')[0].trim();
    
    // Try to get userId from review buttons - most direct source
    const reviewButton = row.querySelector('.btn-review');
    if (reviewButton) {
      const onclick = reviewButton.getAttribute('onclick') || '';
      if (onclick.includes('lineManagerInitialScreeningModal')) {
        // Extract userId (first parameter)
        const userIdMatch = onclick.match(/lineManagerInitialScreeningModal\s*\(\s*['"]([^'"]*)['"]/);
        if (userIdMatch && userIdMatch[1]) {
          const userId = userIdMatch[1];
          
          // Store by name for easy lookup
          window.mainTableUserIds[fullName] = userId;
          
          // Extract score after curly brace
          const scoreMatch = onclick.match(/},\s*['"]([^'"]*)['"]/);
          if (scoreMatch && scoreMatch[1]) {
            const score = scoreMatch[1];
            
            // Store score by both userId and name
            window.mainTableScores[userId] = score;
            window.mainTableScores[fullName] = score;
            
            console.log(`Extracted from main table - Name: ${fullName}, UserId: ${userId}, Score: ${score}`);
          }
        }
      }
    }
  });
  
  console.log(`Extracted ${Object.keys(window.mainTableScores).length} scores from main table`);
  console.log("UserIds mapped:", Object.keys(window.mainTableUserIds).length);
}



function updateAwaitingActionTable(awaitingRowsP1, awaitingRowsP3) {
  const awaitingActionTable = document.getElementById('awaitingActionTable');
  if (!awaitingActionTable) return;
  
  const awaitingTbody = awaitingActionTable.querySelector('tbody');
  if (!awaitingTbody) return;
  
  // Empty the tbody first
  awaitingTbody.innerHTML = '';
  
  // Update section heading to "Awaiting for Action"
  const awaitingHeader = document.querySelector('h4:nth-of-type(1)');
  if (awaitingHeader) {
    awaitingHeader.textContent = 'Awaiting for Action';
  }
  
  // Add content depending on whether we have rows
  if (awaitingRowsP1.length > 0 || awaitingRowsP3.length > 0) {
    // Add P1 rows if we have any
    if (awaitingRowsP1.length > 0) {
      // Add the section header
      const p1HeaderRow = document.createElement('tr');
      p1HeaderRow.classList.add('section-header-row');
      p1HeaderRow.innerHTML = `<td colspan="7" style="background-color: #f0f0f0; font-weight: bold; padding: 8px;">List of P1 Applicants on Review</td>`;
      awaitingTbody.appendChild(p1HeaderRow);
      
      // Add each P1 row WITHOUT Toggle Status column
      awaitingRowsP1.forEach((rowData, idx) => {
        // Create row without Toggle Status column
        const newRow = createTableRow(rowData, false);
        awaitingTbody.appendChild(newRow);
        
        // Set userId attribute on the row
        if (rowData.userId) {
          newRow.setAttribute('data-userid', rowData.userId);
        }
        
        // Get the score directly from database for this userId
        if (rowData.userId) {
          getTotalScoreDirectly(rowData.userId, newRow);
        }
      });
    }
    
    // Add P3 rows if we have any
    if (awaitingRowsP3.length > 0) {
      // Add the section header
      const p3HeaderRow = document.createElement('tr');
      p3HeaderRow.classList.add('section-header-row');
      p3HeaderRow.innerHTML = `<td colspan="7" style="background-color: #f0f0f0; font-weight: bold; padding: 8px;">List of P3 Applicants on Review</td>`;
      awaitingTbody.appendChild(p3HeaderRow);
      
      // Add each P3 row WITHOUT Toggle Status column
      awaitingRowsP3.forEach((rowData, idx) => {
        const newRow = createTableRow(rowData, false);
        awaitingTbody.appendChild(newRow);
        
        // Set userId attribute on the row
        if (rowData.userId) {
          newRow.setAttribute('data-userid', rowData.userId);
        }
        
        // Get the score directly from database for this userId
        if (rowData.userId) {
          getTotalScoreDirectly(rowData.userId, newRow);
        }
      });
    }
  } else {
    // If no rows, display a message
    displayNoDataMessage(awaitingActionTable, 'No applicants awaiting review.');
  }
}
    
function updateDeclaredResultsTable(declaredRowsP1, declaredRowsP3) {
  console.log("Updating declared results table with proper scores from main table...");
  
  // Make sure we have the latest scores from the main table
  extractScoresFromMainTable();
  
  const declaredResultsTable = document.getElementById('declaredResultsTable');
  if (!declaredResultsTable) {
    console.log("Declared results table not found");
    return;
  }
  
  // Make sure the table has proper headers
  ensureTableHeaders();
  
  const declaredTbody = declaredResultsTable.querySelector('tbody');
  if (!declaredTbody) {
    console.log("Tbody not found in declared results table");
    return;
  }
  
  // Empty the tbody first
  declaredTbody.innerHTML = '';
  
  // Update section heading
  const currentPhaseSpan = document.querySelector('#currentPhase');
  if (currentPhaseSpan) {
    currentPhaseSpan.textContent = "Review";
  }
  
  const declaredHeader = document.querySelector('h4:nth-of-type(2)');
  if (declaredHeader) {
    declaredHeader.innerHTML = 'Applicants on <span id="currentPhase">Review</span> Declared Results';
  }
  
  // Add content depending on whether we have rows
  if (declaredRowsP1.length > 0 || declaredRowsP3.length > 0) {
    // Process P1 rows first if we have any
    if (declaredRowsP1.length > 0) {
      console.log(`Adding ${declaredRowsP1.length} P1 rows to declared results`);
      
      // Add the section header
      const p1HeaderRow = document.createElement('tr');
      p1HeaderRow.classList.add('section-header-row');
      p1HeaderRow.innerHTML = `<td colspan="8" style="background-color: #f0f0f0; font-weight: bold; padding: 8px;">List of P1 Applicants on Review - Declared Results</td>`;
      declaredTbody.appendChild(p1HeaderRow);
      
      // CRITICAL FIX: Add each P1 row WITH correct scores from main table
      declaredRowsP1.forEach((rowData, idx) => {
        console.log(`Processing declared row ${idx} - Name: ${rowData.name}`);
        
        // IMPORTANT: Make sure we preserve the score from the original data
        // This is the key fix to prevent N/A scores
        if (rowData.totalScore !== 'N/A') {
          // If the row already has a valid score, make sure we keep it
          console.log(`Row already has score: ${rowData.totalScore}`);
        } else {
          // Look up the userId from our main table mapping if not already set
          if (!rowData.userId && rowData.name) {
            const name = rowData.name.trim();
            if (window.mainTableUserIds && window.mainTableUserIds[name]) {
              rowData.userId = window.mainTableUserIds[name];
              console.log(`Found userId ${rowData.userId} for '${name}' from main table mapping`);
            }
          }
          
          // Look up the score from main table mapping if not already set
          if (rowData.userId) {
            // Try by userId first
            if (window.applicantsScores && window.applicantsScores[rowData.userId]) {
              rowData.totalScore = window.applicantsScores[rowData.userId];
              console.log(`Found score ${rowData.totalScore} for userId ${rowData.userId} from applicantsScores`);
            }
            // Try by userId from mainTableScores
            else if (window.mainTableScores && window.mainTableScores[rowData.userId]) {
              rowData.totalScore = window.mainTableScores[rowData.userId];
              console.log(`Found score ${rowData.totalScore} for userId ${rowData.userId} from mainTableScores`);
            }
          }
          
          // Try by name as a last resort
          if (rowData.totalScore === 'N/A' && rowData.name) {
            const name = rowData.name.trim();
            if (window.mainTableScores && window.mainTableScores[name]) {
              rowData.totalScore = window.mainTableScores[name];
              console.log(`Found score ${rowData.totalScore} for '${name}' from main table by name`);
            }
          }
          
          // If we still don't have a score, try to look it up from the API data
          if (rowData.totalScore === 'N/A' && rowData.userId) {
            const score = findScoreInApplicantsData(rowData.userId);
            if (score && score !== 'N/A') {
              rowData.totalScore = score;
              console.log(`Found score ${rowData.totalScore} for userId ${rowData.userId} from API data`);
            }
          }
        }
        
        // Create a new row WITH Toggle Status column
        const newRow = createTableRow(rowData, true);
        declaredTbody.appendChild(newRow);
        
        // Double-check and fix the score on the new row
        if (rowData.userId) {
          newRow.setAttribute('data-userid', rowData.userId);
          
          // Fix the Change Status button
          const changeButton = newRow.querySelector('.btn-change-status');
          if (changeButton) {
            changeButton.setAttribute('data-userid', rowData.userId);
            changeButton.setAttribute('onclick', `changeApplicantStatus('${rowData.userId}')`);
          }
          
          // Ensure the score cell has the correct value
          const scoreCell = newRow.querySelector('td:nth-child(5)');
          if (scoreCell && rowData.totalScore && rowData.totalScore !== 'N/A') {
            scoreCell.innerHTML = `<span class="score">${rowData.totalScore}</span>`;
            
            // Add color based on score
            const scoreValue = parseFloat(rowData.totalScore);
            if (!isNaN(scoreValue)) {
              if (scoreValue >= 85) {
                scoreCell.classList.add('high-score');
                scoreCell.style.color = 'green';
              } else if (scoreValue >= 75) {
                scoreCell.classList.add('medium-score');
                scoreCell.style.color = 'blue';
              } else {
                scoreCell.classList.add('low-score');
                scoreCell.style.color = 'orange';
              }
            }
          }
        }
      });
    }
    
    // Similar processing for P3 rows
    if (declaredRowsP3.length > 0) {
      // Similar code for P3 rows...
      const p3HeaderRow = document.createElement('tr');
      p3HeaderRow.classList.add('section-header-row');
      p3HeaderRow.innerHTML = `<td colspan="8" style="background-color: #f0f0f0; font-weight: bold; padding: 8px;">List of P3 Applicants on Review - Declared Results</td>`;
      declaredTbody.appendChild(p3HeaderRow);
      
      // Similar processing for P3 rows...
      declaredRowsP3.forEach((rowData, idx) => {
        // Same processing as for P1 rows
        // ... (implement the same logic as for P1 rows)
        
        // IMPORTANT: Make sure we preserve the score from the original data
        if (rowData.totalScore !== 'N/A') {
          // If the row already has a valid score, make sure we keep it
          console.log(`P3 row already has score: ${rowData.totalScore}`);
        } else {
          // Same lookup logic as for P1 rows
          // ...
          
          // Look up the userId if needed
          if (!rowData.userId && rowData.name) {
            const name = rowData.name.trim();
            if (window.mainTableUserIds && window.mainTableUserIds[name]) {
              rowData.userId = window.mainTableUserIds[name];
            }
          }
          
          // Look up the score from various sources
          if (rowData.userId) {
            if (window.applicantsScores && window.applicantsScores[rowData.userId]) {
              rowData.totalScore = window.applicantsScores[rowData.userId];
            } else if (window.mainTableScores && window.mainTableScores[rowData.userId]) {
              rowData.totalScore = window.mainTableScores[rowData.userId];
            }
          }
          
          if (rowData.totalScore === 'N/A' && rowData.name) {
            const name = rowData.name.trim();
            if (window.mainTableScores && window.mainTableScores[name]) {
              rowData.totalScore = window.mainTableScores[name];
            }
          }
          
          // API data lookup
          if (rowData.totalScore === 'N/A' && rowData.userId) {
            const score = findScoreInApplicantsData(rowData.userId);
            if (score && score !== 'N/A') {
              rowData.totalScore = score;
            }
          }
        }
        
        // Create and add the row
        const newRow = createTableRow(rowData, true);
        declaredTbody.appendChild(newRow);
        
        // Set up the row with proper attributes and styling
        if (rowData.userId) {
          newRow.setAttribute('data-userid', rowData.userId);
          
          // Fix the Change Status button
          const changeButton = newRow.querySelector('.btn-change-status');
          if (changeButton) {
            changeButton.setAttribute('data-userid', rowData.userId);
            changeButton.setAttribute('onclick', `changeApplicantStatus('${rowData.userId}')`);
          }
          
          // Format the score cell
          const scoreCell = newRow.querySelector('td:nth-child(5)');
          if (scoreCell && rowData.totalScore && rowData.totalScore !== 'N/A') {
            scoreCell.innerHTML = `<span class="score">${rowData.totalScore}</span>`;
            
            // Add color based on score
            const scoreValue = parseFloat(rowData.totalScore);
            if (!isNaN(scoreValue)) {
              if (scoreValue >= 85) {
                scoreCell.classList.add('high-score');
                scoreCell.style.color = 'green';
              } else if (scoreValue >= 75) {
                scoreCell.classList.add('medium-score');
                scoreCell.style.color = 'blue';
              } else {
                scoreCell.classList.add('low-score');
                scoreCell.style.color = 'orange';
              }
            }
          }
        }
      });
    }
  } else {
    // If no rows, display a message
    displayNoDataMessage(declaredResultsTable, 'No applicants with declared review results.');
  }
  
  // Final fix pass on all rows
  setTimeout(() => {
    // Fix any remaining userId or score issues
    const rows = declaredResultsTable.querySelectorAll('tbody tr:not(.section-header-row)');
    rows.forEach((row, idx) => {
      // Skip message rows
      if (row.querySelector('td[colspan]')) return;
      
      // Get the name for this row
      const nameCell = row.querySelector('td:nth-child(2)');
      if (!nameCell) return;
      
      const name = nameCell.textContent.split('\n')[0].trim();
      
      // Fix userId if missing
      if (!row.getAttribute('data-userid') || row.getAttribute('data-userid') === 'undefined') {
        if (window.mainTableUserIds && window.mainTableUserIds[name]) {
          const userId = window.mainTableUserIds[name];
          row.setAttribute('data-userid', userId);
          console.log(`Fixed userId ${userId} for row ${idx} with name '${name}'`);
          
          // Fix change button too
          const changeButton = row.querySelector('.btn-change-status');
          if (changeButton) {
            changeButton.setAttribute('data-userid', userId);
            changeButton.setAttribute('onclick', `changeApplicantStatus('${userId}')`);
          }
        }
      }
      
      // Fix score if showing N/A but we have the score in our mapping
      const scoreCell = row.querySelector('td:nth-child(5)');
      if (scoreCell && scoreCell.textContent.trim() === 'N/A') {
        const userId = row.getAttribute('data-userid');
        
        // Try to find score from various sources
        let foundScore = null;
        
        // Try by name first
        if (window.mainTableScores && window.mainTableScores[name]) {
          foundScore = window.mainTableScores[name];
        }
        // Try by userId
        else if (userId && window.applicantsScores && window.applicantsScores[userId]) {
          foundScore = window.applicantsScores[userId];
        }
        else if (userId && window.mainTableScores && window.mainTableScores[userId]) {
          foundScore = window.mainTableScores[userId];
        }
        // Try looking in API data
        else if (userId) {
          foundScore = findScoreInApplicantsData(userId);
        }
        
        // If we found a score, update the cell
        if (foundScore && foundScore !== 'N/A') {
          scoreCell.innerHTML = `<span class="score">${foundScore}</span>`;
          console.log(`Fixed score ${foundScore} for row ${idx} with name '${name}'`);
          
          // Add color
          const scoreValue = parseFloat(foundScore);
          if (!isNaN(scoreValue)) {
            if (scoreValue >= 85) {
              scoreCell.classList.add('high-score');
              scoreCell.style.color = 'green';
            } else if (scoreValue >= 75) {
              scoreCell.classList.add('medium-score');
              scoreCell.style.color = 'blue';
            } else {
              scoreCell.classList.add('low-score');
              scoreCell.style.color = 'orange';
            }
          }
        }
      }
    });
  }, 100);
}


function findScoreInApplicantsData(userId) {
  // Check if window.applicantsData is available (this should be set when API response is received)
  if (!window.applicantsData || !Array.isArray(window.applicantsData)) {
    return 'N/A';
  }
  
  // Find the applicant with matching userId
  const applicant = window.applicantsData.find(a => a.userId === userId);
  if (!applicant) {
    return 'N/A';
  }
  
  // Check if the initialScreeningAssessment object is available
  if (applicant.initialScreeningAssessment && applicant.initialScreeningAssessment.totalScore !== 'N/A') {
    return applicant.initialScreeningAssessment.totalScore;
  }
  
  return 'N/A';
}

// Build a comprehensive applicant registry from actual data
function buildApplicantRegistry() {
  console.log("Building comprehensive applicant registry...");
  
  // Get the main table (source of truth)
  const mainTable = document.getElementById('mainApplicantTable');
  if (!mainTable) {
    console.log("Main table not found - cannot build registry");
    return;
  }
  
  // Process all rows to extract data
  const rows = mainTable.querySelectorAll('tbody tr');
  
  rows.forEach((row, index) => {
    // Try to extract userId from review button
    const reviewButton = row.querySelector('.btn-review');
    if (reviewButton) {
      const onclick = reviewButton.getAttribute('onclick') || '';
      if (onclick.includes('lineManagerInitialScreeningModal')) {
        // Extract userId (first parameter)
        const userIdMatch = onclick.match(/lineManagerInitialScreeningModal\s*\(\s*['"]([^'"]*)['"]/);
        if (userIdMatch && userIdMatch[1]) {
          const userId = userIdMatch[1];
          
          // Extract name and email
          const nameCell = row.querySelector('td:nth-child(2)');
          if (!nameCell) return;
          
          const fullContent = nameCell.innerHTML;
          const nameParts = fullContent.split('<br>');
          
          let fullName = '';
          if (nameParts.length > 0) {
            fullName = nameParts[0].trim();
          }
          
          let email = '';
          if (nameParts.length > 1) {
            email = nameParts[1].replace(/<[^>]*>/g, '').trim();
          }
          
          // Extract other data
          const deptCell = row.querySelector('td:nth-child(3)');
          const positionCell = row.querySelector('td:nth-child(4)');
          const department = deptCell ? deptCell.textContent.trim() : '';
          const position = positionCell ? positionCell.textContent.trim() : '';
          
          // Get status
          const statusCell = row.querySelector('td:nth-child(5) span');
          const status = statusCell ? statusCell.textContent.trim() : '';
          
          // Extract score from button
          const scoreMatch = onclick.match(/},\s*['"]([^'"]*)['"]/);
          let score = null;
          if (scoreMatch && scoreMatch[1]) {
            score = scoreMatch[1];
            
            // Cache in various places for compatibility
            window.applicantsScores[userId] = score;
            window.mainTableScores[userId] = score;
            window.mainTableScores[fullName] = score;
          }
          
          // Store in registry
          window.applicantRegistry[userId] = {
            userId: userId,
            fullName: fullName,
            email: email,
            department: department,
            position: position,
            status: status,
            score: score
          };
          
          // Store mappings for lookup
          window.nameToUserId[fullName] = userId;
          window.emailToUserId[email] = userId;
          window.mainTableUserIds[fullName] = userId;
          window.applicantNameMapping[fullName] = userId;
          window.applicantStatusMap[userId] = status;
          
          // Mark row with userId
          row.setAttribute('data-userid', userId);
          row.setAttribute('data-name', fullName);
          row.setAttribute('data-email', email);
          
          console.log(`Added userId ${userId}, name '${fullName}' to registry`);
        }
      }
    }
  });
  
  console.log(`Applicant registry built with ${Object.keys(window.applicantRegistry).length} entries`);
}


// 3. Improved function to get total scores for a given userId
function captureInitialScreeningScores() {
console.log("Capturing initial screening scores from lineManagerInitialScreeningModal buttons");

// Get all buttons with lineManagerInitialScreeningModal in their onclick
const reviewButtons = document.querySelectorAll('button[onclick*="lineManagerInitialScreeningModal"]');

if (!window.applicantsScores) {
    window.applicantsScores = {};
}

if (!window.applicantNameMapping) {
    window.applicantNameMapping = {};
}

reviewButtons.forEach(button => {
    const onclickAttr = button.getAttribute('onclick') || '';
    
    try {
        // Extract userId
        const userIdMatch = onclickAttr.match(/lineManagerInitialScreeningModal\s*\(\s*['"]([^'"]*)['"]/);
        if (userIdMatch && userIdMatch[1]) {
            const userId = userIdMatch[1];
            
            // Extract name for mapping
            const row = button.closest('tr');
            if (row) {
                const nameCell = row.querySelector('td:nth-child(2)');
                if (nameCell) {
                    const name = nameCell.textContent.replace(/\s+/g, ' ').trim();
                    window.applicantNameMapping[name] = userId;
                }
            }
            
            // Extract score (after the closing brace of scores object)
            const scoreMatch = onclickAttr.match(/},\s*['"]([^'"]*)['"]/);
            if (scoreMatch && scoreMatch[1]) {
                const score = scoreMatch[1];
                
                // Cache the score
                window.applicantsScores[userId] = score;
                console.log(`Cached score ${score} for userId ${userId}`);
            }
        }
    } catch (error) {
        console.error('Error parsing button onclick:', error);
    }
});

console.log(`Captured ${Object.keys(window.applicantsScores).length} scores`);
}

// ============================
// USER ID & SCORE RETRIEVAL
// ============================

// Get score directly from button attributes
function extractScoreFromButton(userId) {
  // Look for any button containing this userId
  const buttons = document.querySelectorAll(`button[onclick*="'${userId}'"]`);
  for (const button of buttons) {
    const onclickAttr = button.getAttribute('onclick') || '';
    
    // If this is the screening modal function
    if (onclickAttr.includes('lineManagerInitialScreeningModal')) {
      // The score is the parameter after all the nested objects
      // It's typically in the format: }, 'score', 'doc1', 'doc2', 'doc3'
      // or: }, 'score')
      
      // Try to match the score parameter (should be after the closing curly brace)
      const scoreMatch = onclickAttr.match(/},\s*['"]([^'"]*)['"]/);
      if (scoreMatch && scoreMatch[1]) {
        return scoreMatch[1];
      }
    }
  }
  
  return null;
}

// Get reliable userId for a row
function getReliableUserId(row) {
  if (!row) return null;
  
  // First try direct attribute - this is most reliable if already set
  let userId = row.getAttribute('data-userid');
  if (userId && userId !== 'undefined' && userId !== '') {
    return userId;
  }
  
  // Ensure the registry is built
  if (!window.applicantRegistry || Object.keys(window.applicantRegistry).length === 0) {
    buildApplicantRegistry();
  }
  
  // Try getting userId from review button
  const reviewButton = row.querySelector('.btn-review');
  if (reviewButton) {
    const onclick = reviewButton.getAttribute('onclick') || '';
    const userIdMatch = onclick.match(/lineManagerInitialScreeningModal\s*\(\s*['"]([^'"]*)['"]/);
    if (userIdMatch && userIdMatch[1]) {
      userId = userIdMatch[1];
      row.setAttribute('data-userid', userId);
      return userId;
    }
  }
  
  // Try matching by name
  const nameCell = row.querySelector('td:nth-child(2)');
  if (nameCell) {
    const fullName = nameCell.textContent.split('\n')[0].trim();
    
    // Look through registry entries for a name match
    for (const [id, data] of Object.entries(window.applicantRegistry)) {
      if (data.fullName === fullName) {
        userId = id;
        row.setAttribute('data-userid', userId);
        console.log(`Found userId ${userId} by name match: "${fullName}"`);
        return userId;
      }
    }
    
    // Try a less strict match - just check if names contain each other
    for (const [id, data] of Object.entries(window.applicantRegistry)) {
      if (data.fullName && (data.fullName.includes(fullName) || fullName.includes(data.fullName))) {
        userId = id;
        row.setAttribute('data-userid', userId);
        console.log(`Found userId ${userId} by partial name match`);
        return userId;
      }
    }
    
    // Try our name mapping
    if (window.nameToUserId && window.nameToUserId[fullName]) {
      userId = window.nameToUserId[fullName];
      row.setAttribute('data-userid', userId);
      console.log(`Found userId ${userId} from nameToUserId mapping`);
      return userId;
    }
    
    // Try the applicant name mapping
    if (window.applicantNameMapping && window.applicantNameMapping[fullName]) {
      userId = window.applicantNameMapping[fullName];
      row.setAttribute('data-userid', userId);
      console.log(`Found userId ${userId} from applicantNameMapping`);
      return userId;
    }
    
    // Try main table userIds mapping
    if (window.mainTableUserIds && window.mainTableUserIds[fullName]) {
      userId = window.mainTableUserIds[fullName];
      row.setAttribute('data-userid', userId);
      console.log(`Found userId ${userId} from mainTableUserIds mapping`);
      return userId;
    }
  }
  
  // If we get here, we couldn't find a userId
  console.log("WARNING: Could not find userId for this row");
  return null;
}

// Find userId by name (improved version)
function findUserIdByNameImproved(name) {
  if (!name) return null;
  
  // Clean up the name (remove newlines, extra spaces)
  const cleanName = name.replace(/\s+/g, ' ').trim();
  
  // Check if we already have a mapping
  if (window.applicantNameMapping && window.applicantNameMapping[cleanName]) {
    return window.applicantNameMapping[cleanName];
  }
  
  // Get the main table
  const mainTable = document.getElementById('mainApplicantTable');
  if (!mainTable) return null;
  
  // Search all rows
  const rows = mainTable.querySelectorAll('tbody tr');
  for (const row of rows) {
    const nameCell = row.querySelector('td:nth-child(2)');
    if (!nameCell) continue;
    
    const cellNameText = nameCell.textContent.replace(/\s+/g, ' ').trim();
    
    // Check for exact match first
    if (cellNameText === cleanName) {
      // Try to get userId from review button
      const reviewButton = row.querySelector('.btn-review');
      if (reviewButton) {
        const onclickAttr = reviewButton.getAttribute('onclick') || '';
        const userIdMatch = onclickAttr.match(/lineManagerInitialScreeningModal\s*\(\s*['"]([^'"]*)['"]/);
        if (userIdMatch && userIdMatch[1]) {
          // Save to mapping for future lookups
          if (!window.applicantNameMapping) window.applicantNameMapping = {};
          window.applicantNameMapping[cleanName] = userIdMatch[1];
          
          return userIdMatch[1];
        }
      }
    }
  }
  
  return null;
}

// ============================
// TABLE MANAGEMENT FUNCTIONS
// ============================

// Create a table row with appropriate data
function createTableRow(rowData, isForDeclaredResults = false) {
  const newRow = document.createElement('tr');
  
  // Add userId as data attribute - CRITICAL for change status functionality
  if (rowData.userId) {
    newRow.setAttribute('data-userid', rowData.userId);
  }
  
  // Add criteria status data attribute
  newRow.setAttribute('data-criteria', rowData.criteriaStatus || 'unknown');
  
  // For each cell in the stored data, create a new td element
  rowData.cells.forEach(cellHTML => {
    const cell = document.createElement('td');
    cell.innerHTML = cellHTML;
    newRow.appendChild(cell);
  });
  
  // Only add Change Status column if this is for the declared results table
  if (isForDeclaredResults) {
    const changeStatusCell = document.createElement('td');
    
    // Get the userId value
    const userId = rowData.userId || '';
    
    // Create the button with the userId
    changeStatusCell.innerHTML = `
      <button 
        class="btn-change-status" 
        data-userid="${userId}"
        onclick="changeApplicantStatus('${userId}')"
      >
        Change Status
      </button>
    `;
    
    newRow.appendChild(changeStatusCell);
  }
  
  return newRow;
}

// Fix all scores in all tables
function fixAllTableScores() {
  // First, make sure we've captured all available data
  captureApplicantsDataEnhanced();
  
  const tables = [
    document.getElementById('awaitingActionTable'),
    document.getElementById('declaredResultsTable'),
    document.getElementById('jobOfferTable')
  ].filter(table => table !== null);
  
  tables.forEach(table => {
    const rows = table.querySelectorAll('tbody tr:not(.section-header-row)');
    console.log(`Fixing scores for ${rows.length} rows in ${table.id}`);
    
    rows.forEach((row, idx) => {
      // Skip rows with no content or message rows
      if (row.querySelector('td[colspan]')) return;
      
      // Try to get userId from the row attribute
      let userId = row.getAttribute('data-userid');
      
      if (!userId) {
        // Try to find userId by name
        const nameCell = row.querySelector('td:nth-child(2)');
        if (nameCell) {
          const name = nameCell.textContent.replace(/\s+/g, ' ').trim();
          const foundUserId = findUserIdByNameImproved(name);
          if (foundUserId) {
            row.setAttribute('data-userid', foundUserId);
            userId = foundUserId;
          }
        }
      }
      
      if (userId) {
        // When we have a userId, use the aggressive score fetch method
        forceDatabaseScoreFetch(userId, row);
      }
    });
  });
  
  console.log("All table scores have been fixed");
}

// Force database score fetch for a row
function forceDatabaseScoreFetch(userId, row) {
  if (!userId || !row) {
    console.log("Missing userId or row in forceDatabaseScoreFetch");
    return;
  }
  
  console.log(`Forcing database score fetch for userId: ${userId}`);
  
  // Extract score directly from button attributes with userId
  const score = extractScoreFromButton(userId);
  
  if (score) {
    // Cache the score
    if (!window.applicantsScores) window.applicantsScores = {};
    window.applicantsScores[userId] = score;
    
    // Update the row
    updateScoreCellWithFormatting(row, score);
    console.log(`Set score ${score} from database for userId ${userId}`);
    return;
  }
  
  // If score not found in buttons, try the cache
  if (window.applicantsScores && window.applicantsScores[userId]) {
    const cachedScore = window.applicantsScores[userId];
    updateScoreCellWithFormatting(row, cachedScore);
    console.log(`Used cached score ${cachedScore} for userId ${userId}`);
    return;
  }
  
  // If still not found, use N/A
  console.log(`No database score found for userId ${userId}`);
  updateScoreCellWithFormatting(row, 'N/A');
}

// Extract row data for creating a table row
function extractRowData(row, index) {
  const cells = Array.from(row.querySelectorAll('td'));
  const cellData = cells.map(cell => cell.innerHTML);
  
  // Get userId using our reliable method
  const userId = getReliableUserId(row);
  
  // Get totalScore - only from real data
  let totalScore = 'N/A';
  
  // Method 1: Check registry
  if (userId && window.applicantRegistry && window.applicantRegistry[userId]) {
    totalScore = window.applicantRegistry[userId].score || 'N/A';
  } 
  // Method 2: Check for review button with score data
  else {
    const reviewButton = row.querySelector('.btn-review');
    if (reviewButton) {
      const onclick = reviewButton.getAttribute('onclick') || '';
      const scoreMatch = onclick.match(/},\s*['"]([^'"]*)['"]/);
      if (scoreMatch && scoreMatch[1]) {
        totalScore = scoreMatch[1];
      }
    }
  }
  
  // Get name and email from the actual row (real data)
  let applicantName = '';
  let applicantEmail = '';
  
  if (cells.length > 1) {
    const nameCell = cells[1];
    const fullContent = nameCell.innerHTML;
    const nameParts = fullContent.split('<br>');
    
    if (nameParts.length > 0) {
      applicantName = nameParts[0].trim();
    }
    
    if (nameParts.length > 1) {
      const emailHtml = nameParts[1];
      applicantEmail = emailHtml.replace(/<[^>]*>/g, '').trim();
    }
  }
  
  // Build the cells array for the new row - keeping original data structure
  const result = [
    cellData[0], // Applicant No
    cellData[1], // Last Name, First Name
    cellData[2], // Department
    cellData[3], // Position Applied
    totalScore,  // Total Score
    '<span class="criteria-passed">Passed</span>', // Work Setup/Availability
    cellData[4]  // Applicant Status
  ];
  
  // Log what we're returning
  console.log(`Row ${index} data from real source:`, {
    userId: userId,
    totalScore: totalScore,
    name: applicantName,
    email: applicantEmail
  });
  
  return {
    index: index + 1,
    cells: result,
    userId: userId,
    totalScore: totalScore,
    criteriaStatus: 'passed',
    name: applicantName,
    email: applicantEmail
  };
}

// Rebuild all table rows to ensure they have userIds
function rebuildAllTableRows() {
  console.log("REBUILD: Analyzing all table rows to ensure they have userIds...");
  
  // We'll only look at the declared results table since that's where the change status buttons are
  const declaredTable = document.getElementById('declaredResultsTable');
  if (!declaredTable) {
    console.log("REBUILD: Declared results table not found");
    return;
  }
  
  const rows = declaredTable.querySelectorAll('tbody tr');
  console.log(`REBUILD: Checking ${rows.length} rows in declared results table`);
  
  rows.forEach((row, index) => {
    // Skip header rows and empty rows
    if (row.classList.contains('section-header-row') || row.querySelector('td[colspan]')) {
      return;
    }
    
    // Get current userId if any
    let userId = row.getAttribute('data-userid');
    let foundUserId = false;
    
    // If no userId, try to get it using various methods
    if (!userId || userId === 'undefined' || userId === '') {
      // Try by name
      const nameCell = row.querySelector('td:nth-child(2)');
      if (nameCell) {
        // Try full display name first
        const displayName = nameCell.textContent.replace(/\s+/g, ' ').trim();
        if (displayName && window.displayNameToUserId[displayName]) {
          userId = window.displayNameToUserId[displayName];
          foundUserId = true;
          console.log(`REBUILD: Found userId ${userId} for row ${index} using display name`);
        }
        
        // If that didn't work, try just the name part
        if (!foundUserId) {
          const fullContent = nameCell.innerHTML;
          const nameParts = fullContent.split('<br>');
          if (nameParts.length > 0) {
            const name = nameParts[0].trim();
            if (name && window.nameToUserId[name]) {
              userId = window.nameToUserId[name];
              foundUserId = true;
              console.log(`REBUILD: Found userId ${userId} for row ${index} using name`);
            }
          }
        }
        
        // If still no match, try email
        if (!foundUserId) {
          const fullContent = nameCell.innerHTML;
          const nameParts = fullContent.split('<br>');
          if (nameParts.length > 1) {
            const emailHtml = nameParts[1];
            const email = emailHtml.replace(/<[^>]*>/g, '').trim();
            if (email && window.emailToUserId[email]) {
              userId = window.emailToUserId[email];
              foundUserId = true;
              console.log(`REBUILD: Found userId ${userId} for row ${index} using email`);
            }
          }
        }
      }
    } else {
      foundUserId = true;
    }
    
    // If we found a userId, update it on the row
    if (foundUserId && userId) {
      row.setAttribute('data-userid', userId);
      
      // Also fix the change status button if it exists
      const changeButton = row.querySelector('.btn-change-status');
      if (changeButton) {
        changeButton.setAttribute('data-userid', userId);
        changeButton.setAttribute('onclick', `changeApplicantStatus('${userId}')`);
        console.log(`REBUILD: Updated change status button for row ${index} with userId ${userId}`);
      }
    }
  });
  
  console.log("REBUILD: Completed row analysis and updates");
}

// Fix all change status buttons
function fixAllChangeStatusButtons() {
  console.log("Fixing Change Status buttons...");
  
  // Get all buttons
  const buttons = document.querySelectorAll('.btn-change-status');
  
  buttons.forEach((button, index) => {
    // Check if already has userId
    let userId = button.getAttribute('data-userid');
    
    if (!userId || userId === 'undefined' || userId === '') {
      // Try getting from parent row
      const row = button.closest('tr');
      if (row) {
        userId = getReliableUserId(row);
      }
    }
    
    // If we have a userId, update the button
    if (userId && userId !== 'undefined' && userId !== '') {
      button.setAttribute('data-userid', userId);
      button.setAttribute('onclick', `changeApplicantStatus('${userId}')`);
    }
  });
}

// Update score cell with appropriate formatting
function updateScoreCellWithFormatting(row, score) {
  if (!row) {
    console.log("Missing row in updateScoreCellWithFormatting");
    return;
  }
  
  const scoreCell = row.querySelector('td:nth-child(5)');
  if (!scoreCell) {
    console.log("Score cell not found in row");
    return;
  }
  
  // Format and display the score
  let formattedScore;
  if (score === 'N/A' || score === undefined || score === null || score === '') {
    formattedScore = 'N/A';
  } else {
    const scoreValue = parseFloat(score);
    formattedScore = isNaN(scoreValue) ? 'N/A' : scoreValue.toFixed(1);
  }
  
  // Store the score value as a data attribute on the row
  row.setAttribute('data-score', formattedScore);
  
  // Update the cell content
  scoreCell.innerHTML = `<span class="score">${formattedScore}</span>`;
  
  // Add color based on score
  if (formattedScore !== 'N/A') {
    const scoreValue = parseFloat(formattedScore);
    
    // Remove any existing color classes
    scoreCell.classList.remove('high-score', 'medium-score', 'low-score');
    
    // Apply appropriate color based on score value
    if (scoreValue >= 85) {
      scoreCell.classList.add('high-score');
      scoreCell.style.color = 'green';
    } else if (scoreValue >= 75) {
      scoreCell.classList.add('medium-score');
      scoreCell.style.color = 'blue';
    } else {
      scoreCell.classList.add('low-score');
      scoreCell.style.color = 'orange';
    }
  }
}

// ============================
// FILTER & DISPLAY FUNCTIONS
// ============================

// Filter table rows by status
function filterRowsByStatus(status) {
  console.log("Filtering by status:", status);
  
  // Get references to elements
  const mainTable = document.getElementById('mainApplicantTable');
  const onboardingTable = document.getElementById('onboardingTable');
  const onboardingHeader = document.getElementById('onboardingHeader');
  const applicantStatusSection = document.getElementById('applicantStatusSection');
  
  // Get all rows
  const allMainRows = mainTable ? Array.from(mainTable.querySelectorAll('tbody tr')) : [];
  const allOnboardingRows = onboardingTable ? Array.from(onboardingTable.querySelectorAll('tbody tr')) : [];
  
  // Hide/show applicant status section based on filter
  if (applicantStatusSection) {
    applicantStatusSection.style.display = (status === 'all') ? 'none' : 'block';
  }
  
  // "All" filter: Show everything in the main table
  if (status === 'all') {
    // Show all rows in main table
    allMainRows.forEach(row => row.style.display = '');
    
    // Show all rows in onboarding table
    allOnboardingRows.forEach(row => row.style.display = '');
    
    // Show onboarding section header
    if (onboardingHeader) onboardingHeader.style.display = '';
    
    // Show onboarding table
    if (onboardingTable) onboardingTable.style.display = '';
    
    // Highlight the active filter button
    highlightActiveFilter(status);
    return;
  }
  
  // Hide all rows in the main table by default
  allMainRows.forEach(row => row.style.display = 'none');
  
  // Special handling for "For Review" button
  if (status === 'forreview') {
    handleReviewFilter(mainTable, applicantStatusSection, allMainRows);
    return;
  }
  
  // For "For Evaluation" button
  if (status === 'forevaluation') {
    handleEvaluationFilter(onboardingHeader, onboardingTable, allMainRows);
    return;
  }
  
  // For "For Onboarding" filter
  if (status === 'foronboarding') {
    handleOnboardingFilter(applicantStatusSection, onboardingHeader, onboardingTable, allOnboardingRows);
    return;
  }
  
  // Highlight the active filter button
  highlightActiveFilter(status);
}

// Handle the "For Review" filter
function handleReviewFilter(mainTable, applicantStatusSection, allMainRows) {
  // Hide onboarding section for review filter
  const onboardingHeader = document.getElementById('onboardingHeader');
  const onboardingTable = document.getElementById('onboardingTable');
  
  if (onboardingHeader) onboardingHeader.style.display = 'none';
  if (onboardingTable) onboardingTable.style.display = 'none';
  
  // HIDE THE MAIN TABLE - this is what was missing
  if (mainTable) mainTable.style.display = 'none';
  
  // Ensure we have the most up-to-date data
  captureApplicantsDataEnhanced();
  
  // Update the current phase
  const phaseSpans = document.querySelectorAll('#currentPhase');
  phaseSpans.forEach(span => span.textContent = "Review");
  
  // Ensure the tables have proper headers
  ensureTableHeaders();
  
  // Arrays to store rows from main table
  const awaitingRowsP1 = [];
  const declaredRowsP1 = [];
  const awaitingRowsP3 = [];
  const declaredRowsP3 = [];
  const jobOfferRowsP3 = [];
  
  // Process each row and categorize it
  allMainRows.forEach((row, index) => {
    const lastCell = row.querySelector('td:last-child');
    if (!lastCell) return;
    
    // Get status text from the span element in the last cell
    const statusSpan = lastCell.querySelector('span');
    if (!statusSpan) return;
    
    const statusText = statusSpan.textContent.trim();
    
    // Extract row data with proper score and userId
    const rowData = extractRowData(row, index);
    
    // Ensure the userId is captured for the row
    if (rowData.userId) {
      row.setAttribute('data-userid', rowData.userId);
    }
    
    // Check for P1 - Awaiting for Line Manager Action; HR PASSED
    if (statusText.indexOf("P1 - Awaiting for Line Manager Action; HR PASSED") !== -1) {
      awaitingRowsP1.push(rowData);
    }
    // Check for P1 - PASSED or P1: PASSED
    else if (statusText.indexOf("P1 - PASSED") !== -1 || statusText.indexOf("P1: PASSED") !== -1) {
      declaredRowsP1.push(rowData);
    }
    // Check for P1 - FAILED or P1: FAILED
    else if (statusText.indexOf("P1 - FAILED") !== -1 || statusText.indexOf("P1: FAILED") !== -1) {
      declaredRowsP1.push(rowData);
    }
    // Check for P3 - Line Manager Evaluation Accomplished
    else if (statusText.indexOf("P3 - Line Manager Evaluation Accomplished") !== -1) {
      awaitingRowsP3.push(rowData);
    }
    // Check for P3 - PASSED or P3: PASSED (not Job Offer)
    else if ((statusText.indexOf("P3 - PASSED") !== -1 || statusText.indexOf("P3: PASSED") !== -1) && 
            statusText.indexOf("Job Offer") === -1) {
      declaredRowsP3.push(rowData);
    }
    // Check for P3 - FAILED or P3: FAILED
    else if (statusText.indexOf("P3 - FAILED") !== -1 || statusText.indexOf("P3: FAILED") !== -1) {
      declaredRowsP3.push(rowData);
    }
    // Check for P3 - PASSED - Job Offer Sent
    else if (statusText.indexOf("P3 - PASSED - Job Offer Sent") !== -1) {
      jobOfferRowsP3.push(rowData);
    }
    // Check for "For Review" button as a fallback
    else {
      const hasReviewButton = Array.from(lastCell.querySelectorAll('button')).some(button => 
        button.textContent.trim() === 'For Review'
      );
      
      if (hasReviewButton) {
        if (statusText.indexOf("P1") !== -1) {
          awaitingRowsP1.push(rowData);
        } else if (statusText.indexOf("P3") !== -1) {
          awaitingRowsP3.push(rowData);
        }
      }
    }
  });
  
  // Update Awaiting Action table
  updateAwaitingActionTable(awaitingRowsP1, awaitingRowsP3);
  
  // Update Declared Results table
  updateDeclaredResultsTable(declaredRowsP1, declaredRowsP3);
  
  // Handle Job Offer section
  updateJobOfferSection(jobOfferRowsP3, applicantStatusSection);
  
  // Update section visibilities based on data presence
  updateReviewSectionsVisibility(
    awaitingRowsP1.length + awaitingRowsP3.length > 0,
    declaredRowsP1.length + declaredRowsP3.length > 0,
    jobOfferRowsP3.length > 0,
    awaitingRowsP1.length > 0,  // Has P1 data flag
    awaitingRowsP3.length > 0   // Has P3 data flag
  );
  
  // Fix scores after a short delay to ensure tables have been populated
  setTimeout(() => {
    window.fixAllTableScores();
    fixChangeStatusButtons(); // Make sure Change Status buttons have correct userId
  }, 300);
  
  // Highlight the active filter button
  highlightActiveFilter(status);

  // Update the header buttons based on data
  updateSectionHeaderButtons();
}




// Enhanced capture of applicants data
function captureApplicantsDataEnhanced() {
  console.log("Enhanced capture of all applicants data with improved user-specific score tracking");
  
  // Initialize the global caches if they don't exist
  window.applicantsScores = window.applicantsScores || {};
  window.applicantNameMapping = window.applicantNameMapping || {};
  
  // Get the main table where all applicant data is displayed
  const mainTable = document.getElementById('mainApplicantTable');
  if (!mainTable) {
    console.log("Main table not found");
    return;
  }
  
  // Process all rows in the main table
  const rows = mainTable.querySelectorAll('tbody tr');
  
  rows.forEach((row, idx) => {
    // Get the name for mapping
    const nameCell = row.querySelector('td:nth-child(2)');
    const applicantName = nameCell ? nameCell.textContent.replace(/\s+/g, ' ').trim() : '';
    
    // Extract userId and score from review buttons
    const reviewButton = row.querySelector('.btn-review');
    if (reviewButton) {
      const onclickAttr = reviewButton.getAttribute('onclick') || '';
      if (onclickAttr.includes('lineManagerInitialScreeningModal')) {
        try {
          // Extract userId from the first parameter
          const userIdMatch = onclickAttr.match(/lineManagerInitialScreeningModal\s*\(\s*['"]([^'"]*)['"]/);
          if (userIdMatch && userIdMatch[1]) {
            const userId = userIdMatch[1];
            
            // Store name to userId mapping
            if (applicantName) {
              window.applicantNameMapping[applicantName] = userId;
            }
            
            // Extract totalScore - it's the parameter after the closing curly brace }
            // This is the applicant_initialscreening_assessment.totalScore value
            const scoreMatch = onclickAttr.match(/},\s*['"]([^'"]*)['"]/);
            if (scoreMatch && scoreMatch[1]) {
              const totalScore = scoreMatch[1];
              
              // Store in score cache with userId as key
              window.applicantsScores[userId] = totalScore;
              console.log(`Row ${idx+1}: Stored score ${totalScore} for userId ${userId}, name ${applicantName}`);
            } else {
              console.log(`Row ${idx+1}: No score found in onclick attribute for userId ${userId}`);
            }
          }
        } catch (error) {
          console.error(`Error processing row ${idx+1}:`, error);
        }
      }
    }
  });
  
  console.log(`Enhanced capture completed: Found ${Object.keys(window.applicantsScores).length} user-specific scores`);
}


// Handle the "For Onboarding" filter
function handleOnboardingFilter(applicantStatusSection, onboardingHeader, onboardingTable, allOnboardingRows) {
  // Hide applicant status section for onboarding filter
  if (applicantStatusSection) {
    applicantStatusSection.style.display = 'none';
  }
  
  // Show onboarding section header
  if (onboardingHeader) {
    onboardingHeader.style.display = 'block';
    onboardingHeader.textContent = 'Onboarding';
  }
  
  // Show onboarding table
  if (onboardingTable) {
    onboardingTable.style.display = 'table';
  }
  
  // Define all possible onboarding statuses
  const onboardingStatuses = [
    'Onboarding - First Day Checklist Sent', 
    'Onboarding - Checklist Accomplished', 
    'Onboarding - Account Created',
    'First Day Checklist Sent',
    'Checklist Accomplished',
    'Account Created'
  ];
  
  // Count visible rows to check if we have data
  let visibleRowCount = 0;
  
  // Show rows with onboarding statuses and hide others
  allOnboardingRows.forEach(row => {
    const lastCell = row.querySelector('td:last-child');
    const statusText = lastCell ? lastCell.textContent.trim() : '';
    
    let showRow = false;
    
    // Check if status matches any onboarding status
    for (const onboardingStatus of onboardingStatuses) {
      if (statusText.includes(onboardingStatus)) {
        showRow = true;
        break;
      }
    }
    
    // Also check for "For Onboarding" button
    if (!showRow && lastCell && lastCell.querySelector('.btn-onboarding')) {
      showRow = true;
    }
    
    // Show or hide the row
    row.style.display = showRow ? '' : 'none';
    
    if (showRow) {
      visibleRowCount++;
    }
  });
  
  // If no rows are visible, display a message
  if (onboardingTable && visibleRowCount === 0) {
    const tbody = onboardingTable.querySelector('tbody');
    
    if (tbody) {
      // Clear the table first
      tbody.innerHTML = '';
      
      // Add a message row
      const messageRow = document.createElement('tr');
      const messageCell = document.createElement('td');
      
      messageCell.setAttribute('colspan', '5');
      messageCell.className = 'text-center no-data-message';
      messageCell.textContent = 'No applicants awaiting for onboarding.';
      
      messageRow.appendChild(messageCell);
      tbody.appendChild(messageRow);
    }
  }
  
  // Highlight the active filter button
  highlightActiveFilter('foronboarding');
}

// Filter table rows based on search input
function filterTable() {
  const searchBar = document.getElementById("searchBar");
  if (!searchBar) return;
  
  const searchValue = searchBar.value.toLowerCase();
  const rows = document.querySelectorAll('.tracking-table tbody tr');
  
  rows.forEach(row => {
    // Skip header rows
    if (row.classList.contains('section-header-row')) return;
    
    const rowText = Array.from(row.querySelectorAll('td'))
      .map(cell => cell.textContent.toLowerCase())
      .join(' ');
      
    row.style.display = rowText.includes(searchValue) ? '' : 'none';
  });
}

// Display no data message in a table
function displayNoDataMessage(table, message) {
  if (!table) return;
  
  const tbody = table.querySelector('tbody');
  if (!tbody) return;
  
  // Check if we already have a message row
  const existingMessage = tbody.querySelector('tr td[colspan].text-center');
  
  if (existingMessage) {
    // Update existing message
    existingMessage.textContent = message;
  } else {
    // Clear the tbody first
    tbody.innerHTML = '';
    
    // Create message row
    const messageRow = document.createElement('tr');
    const messageCell = document.createElement('td');
    
    // Get the correct colspan from table headers
    const headerCells = table.querySelectorAll('thead th');
    const colspan = headerCells.length || 7;
    
    messageCell.setAttribute('colspan', colspan.toString());
    messageCell.className = 'text-center no-data-message';
    messageCell.textContent = message;
    
    messageRow.appendChild(messageCell);
    tbody.appendChild(messageRow);
  }
}

// Highlight the active filter button
function highlightActiveFilter(status) {
  document.querySelectorAll(".filter-button").forEach(button => {
    button.classList.remove("active");
  });
  
  const buttonId = status === "all" ? "filter-all" : `filter-${status}`;
  const activeButton = document.getElementById(buttonId);
  
  if (activeButton) {
    activeButton.classList.add("active");
  }
}

// ============================
// TABLE OPERATIONS
// ============================

// Ensure all tables have the right headers
function ensureTableHeaders() {
  // Get all tables that need headers
  const tables = [
    document.getElementById('awaitingActionTable'),
    document.getElementById('declaredResultsTable'),
    document.getElementById('jobOfferTable')
  ].filter(table => table !== null);
  
  tables.forEach(table => {
    // Check if table has header
    const thead = table.querySelector('thead');
    if (!thead || !thead.querySelector('tr th')) {
      // Create header if it doesn't exist
      const newThead = document.createElement('thead');
      
      // Different headers based on table ID
      if (table.id === 'declaredResultsTable') {
        // Declared Results table gets Change Status column
        newThead.innerHTML = `
          <tr>
            <th>Applicant No.</th>
            <th>Last Name, First Name</th>
            <th>Department</th>
            <th>Position Applied</th>
            <th>Total Score</th>
            <th>Work Setup/Availability</th>
            <th>Applicant Status</th>
            <th>Actions</th>
          </tr>
        `;
      } else {
        // Other tables (awaiting action, job offer) don't get Change Status
        newThead.innerHTML = `
          <tr>
            <th>Applicant No.</th>
            <th>Last Name, First Name</th>
            <th>Department</th>
            <th>Position Applied</th>
            <th>Total Score</th>
            <th>Work Setup/Availability</th>
            <th>Applicant Status</th>
          </tr>
        `;
      }
      
      // Replace existing thead or add to beginning of table
      if (thead) {
        table.replaceChild(newThead, thead);
      } else {
        table.insertBefore(newThead, table.firstChild);
      }
    } else {
      // Check and update existing headers
      const headerRow = thead.querySelector('tr');
      const headers = headerRow.querySelectorAll('th');
      
      // Add the Work Setup/Availability column if it doesn't exist
      if (headers.length === 6 && !Array.from(headers).some(h => h.textContent.includes('Work Setup'))) {
        const newTh = document.createElement('th');
        newTh.textContent = 'Work Setup/Availability';
        
        // Insert before the last column (Applicant Status)
        headerRow.insertBefore(newTh, headers[5]);
      }
      
      // Only add Actions to declared results table
      if (table.id === 'declaredResultsTable' && !Array.from(headers).some(h => h.textContent.includes('Actions'))) {
        const actionsTh = document.createElement('th');
        actionsTh.textContent = 'Actions';
        
        // Add as the last column
        headerRow.appendChild(actionsTh);
      }
    }
  });
}

// Fix the header structure
function fixHeaderStructure() {
  // Fix the applicant status section headers
  const awaitingHeader = document.querySelector('h4:nth-of-type(1)');
  const declaredHeader = document.querySelector('h4:nth-of-type(2)');
  
  if (awaitingHeader) {
    awaitingHeader.textContent = 'Awaiting for Action';
  }
  
  if (declaredHeader) {
    const currentPhaseSpan = declaredHeader.querySelector('#currentPhase') || 
                          document.createElement('span');
    currentPhaseSpan.id = 'currentPhase';
    currentPhaseSpan.textContent = 'Review';
    
    // If the header doesn't have the span, add it
    if (!declaredHeader.querySelector('#currentPhase')) {
      declaredHeader.innerHTML = 'Applicants on ';
      declaredHeader.appendChild(currentPhaseSpan);
      declaredHeader.innerHTML += ' Declared Results';
    }
  }
  
  // Ensure all currentPhase spans have the same content
  document.querySelectorAll('#currentPhase').forEach(span => {
    span.textContent = 'Review';
  });
}

// Move a row from one section to another
function moveRowToSection(userId, fromSection, toSection) {
  console.log(`Moving user ${userId} from ${fromSection} to ${toSection}`);
  
  if (!userId || !fromSection || !toSection) {
    console.error("Missing required parameters for row movement");
    return false;
  }
  
  // Get source and target tables
  const sourceTable = document.getElementById(fromSection);
  const targetTable = document.getElementById(toSection);
  
  if (!sourceTable || !targetTable) {
    console.error(`Tables not found: ${fromSection} or ${toSection}`);
    return false;
  }
  
  // Find the row in the source table
  const sourceRows = sourceTable.querySelectorAll('tbody tr');
  let rowToMove = null;
  let rowData = null;
  
  for (const row of sourceRows) {
    // Skip section headers and message rows
    if (row.classList.contains('section-header-row') || row.querySelector('td[colspan]')) {
      continue;
    }
    
    const rowUserId = row.getAttribute('data-userid');
    if (rowUserId === userId) {
      rowToMove = row;
      // Extract the row data before removing it
      rowData = extractRowData(row, 0);
      break;
    }
  }
  
  if (!rowToMove || !rowData) {
    console.error(`Row for user ${userId} not found in ${fromSection}`);
    return false;
  }
  
  // Remove the row from source table
  rowToMove.remove();
  
  // Check if we need to add a "no data" message to source table if it's now empty
  const remainingSourceRows = Array.from(sourceTable.querySelectorAll('tbody tr')).filter(
    row => !row.classList.contains('section-header-row') && !row.querySelector('td[colspan]')
  );
  
  if (remainingSourceRows.length === 0) {
    const sourceTbody = sourceTable.querySelector('tbody');
    if (sourceTbody) {
      // Get column count from table headers
      const headerCount = sourceTable.querySelectorAll('thead th').length;
      const messageRow = document.createElement('tr');
      const messageCell = document.createElement('td');
      messageCell.setAttribute('colspan', headerCount.toString());
      messageCell.className = 'text-center no-data-message';
      messageCell.textContent = 'No applicants awaiting review.';
      messageRow.appendChild(messageCell);
      sourceTbody.appendChild(messageRow);
    }
  }
  
  // Add row to target table with appropriate modifications
  const targetTbody = targetTable.querySelector('tbody');
  if (!targetTbody) {
    console.error(`Target tbody not found in ${toSection}`);
    return false;
  }
  
  // Clear any "no data" message in the target table
  const noDataRow = targetTbody.querySelector('tr td[colspan].text-center');
  if (noDataRow) {
    noDataRow.closest('tr').remove();
  }
  
  // Create new row for target table
  // Special handling for declaredResultsTable - add Toggle Status column
  const needsToggleColumn = (toSection === 'declaredResultsTable');
  const newRow = createTableRow(rowData, needsToggleColumn);
  
  // Set the same userId on the new row
  newRow.setAttribute('data-userid', userId);
  
  // Get section header row that matches P1 or P3
  const isP1 = rowData.cells[6].includes('P1');
  const headerSelector = isP1 ? 'P1' : 'P3';
  
  // Add the row after the appropriate section header
  const sectionHeaders = targetTbody.querySelectorAll('tr.section-header-row');
  let inserted = false;
  
  for (const header of sectionHeaders) {
    if (header.textContent.includes(headerSelector)) {
      // Try to add after the header
      const nextSibling = header.nextSibling;
      if (nextSibling) {
        targetTbody.insertBefore(newRow, nextSibling);
      } else {
        targetTbody.appendChild(newRow);
      }
      inserted = true;
      break;
    }
  }
  
  // If no matching header found, just append to the end
  if (!inserted) {
    targetTbody.appendChild(newRow);
  }
  
  // If moving to declared results, set up the toggle button
  if (needsToggleColumn) {
    const toggleButton = newRow.querySelector('.btn-toggle-status');
    if (toggleButton) {
      toggleButton.setAttribute('data-userid', userId);
      setupToggleStatusButtons();
    }
  }
  
  // Update the score in the new row
  if (window.applicantsScores && window.applicantsScores[userId]) {
    updateScoreCellWithFormatting(newRow, window.applicantsScores[userId]);
  } else {
    getTotalScoreDirectly(userId, newRow);
  }
  
  return true;
}

// Sort declared results based on selected option
function sortDeclaredResults(sortType) {
  const table = document.getElementById('declaredResultsTable');
  if (!table) return;
  
  const tbody = table.querySelector('tbody');
  if (!tbody) return;
  
  const rows = Array.from(tbody.querySelectorAll('tr:not(.section-header-row)'));
  
  // Keep section header rows in place
  const headerRows = Array.from(tbody.querySelectorAll('tr.section-header-row'));
  
  // Group rows by section (P1 and P3)
  const p1Rows = rows.filter(row => {
    const statusCell = row.querySelector('td:nth-child(7)');
    return statusCell && statusCell.textContent.includes('P1');
  });
  
  const p3Rows = rows.filter(row => {
    const statusCell = row.querySelector('td:nth-child(7)');
    return statusCell && statusCell.textContent.includes('P3');
  });
  
  // Sort rows based on selected option
  if (sortType === 'ascending' || sortType === 'descending') {
    // Sort by score
    const sortFn = (a, b) => {
      const scoreA = parseFloat(a.getAttribute('data-score') || '0');
      const scoreB = parseFloat(b.getAttribute('data-score') || '0');
      return sortType === 'ascending' ? scoreA - scoreB : scoreB - scoreA;
    };
    
    p1Rows.sort(sortFn);
    p3Rows.sort(sortFn);
  } else if (sortType === 'alphabetical') {
    // Sort alphabetically by name
    const sortFn = (a, b) => {
      const nameA = a.querySelector('td:nth-child(2)')?.textContent.trim() || '';
      const nameB = b.querySelector('td:nth-child(2)')?.textContent.trim() || '';
      return nameA.localeCompare(nameB);
    };
    
    p1Rows.sort(sortFn);
    p3Rows.sort(sortFn);
  }
  
  // Clear the tbody
  tbody.innerHTML = '';
  
  // Add P1 header and rows if we have any
  if (p1Rows.length > 0) {
    const p1Header = headerRows.find(row => row.textContent.includes('P1'));
    if (p1Header) tbody.appendChild(p1Header);
    p1Rows.forEach(row => tbody.appendChild(row));
  }
  
  // Add P3 header and rows if we have any
  if (p3Rows.length > 0) {
    const p3Header = headerRows.find(row => row.textContent.includes('P3'));
    if (p3Header) tbody.appendChild(p3Header);
    p3Rows.forEach(row => tbody.appendChild(row));
  }
}

// ============================
// APPLICANT STATUS FUNCTIONS
// ============================

// Toggle applicant status (pass/fail)
function toggleApplicantStatus(button) {
  const row = button.closest('tr');
  if (!row) return;
  
  const userId = button.getAttribute('data-userid') || row.getAttribute('data-userid');
  if (!userId) {
    console.error("Cannot toggle status: Missing userId");
    alert("Error: Cannot identify the applicant to update status");
    return;
  }
  
  // Get current status
  const statusCell = row.querySelector('td:nth-child(7)');
  if (!statusCell) return;
  
  const currentStatus = statusCell.textContent.trim();
  console.log(`Toggling status for userId ${userId}, current status: ${currentStatus}`);
  
  // Toggle between PASSED and FAILED
  let newStatus;
  let apiEndpoint;
  
  if (currentStatus.includes('PASSED')) {
    // If already PASSED, change to FAILED
    newStatus = currentStatus.includes('P1') ? 'P1 - FAILED (Pending Finalization)' : 'P3 - FAILED (Pending Finalization)';
    apiEndpoint = currentStatus.includes('P1') ? 'markAsP1Failed' : 'markAsP3Failed';
    button.classList.remove('status-passed');
    button.classList.add('status-failed');
    button.textContent = 'Failed';
  } else if (currentStatus.includes('FAILED')) {
    // If already FAILED, change to PASSED
    newStatus = currentStatus.includes('P1') ? 'P1 - PASSED (Pending Finalization)' : 'P3 - PASSED (Pending Finalization)';
    apiEndpoint = currentStatus.includes('P1') ? 'markAsP1Passed' : 'markAsP3Passed';
    button.classList.remove('status-failed');
    button.classList.add('status-passed');
    button.textContent = 'Passed';
  } else {
    // Default to PASSED if status doesn't contain either keyword
    if (currentStatus.includes('P1')) {
      newStatus = 'P1 - PASSED (Pending Finalization)';
      apiEndpoint = 'markAsP1Passed';
    } else {
      newStatus = 'P3 - PASSED (Pending Finalization)';
      apiEndpoint = 'markAsP3Passed';
    }
    button.classList.add('status-passed');
    button.textContent = 'Passed';
  }
  
  // Update the status cell
  statusCell.textContent = newStatus;
  
  // Store the pending status change
  if (!window.pendingStatusChanges) {
    window.pendingStatusChanges = {};
  }
  
  // Record whether this is a PASS or FAIL
  window.pendingStatusChanges[userId] = newStatus.includes('PASSED') ? 'PASSED' : 'FAILED';
  
  console.log(`Status change for userId ${userId} to ${newStatus} is pending finalization`);
  
  // Make API call to update the temporary status in the database
  fetch(`/linemanager/applicant-tracker-jobposition/${apiEndpoint}`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({ userId: userId }),
  })
  .then(response => response.json())
  .then(data => {
    if (!data.success) {
      console.error(`Error updating temporary status: ${data.message || 'Unknown error'}`);
    }
  })
  .catch(error => {
    console.error('Error calling temporary status API:', error);
  });
}

// Check if all applicants in the current phase have been marked
function checkAllApplicantsMarked(phase = null) {
  const declaredResultsTable = document.getElementById("declaredResultsTable");
  if (!declaredResultsTable) return true;
  
  const rows = declaredResultsTable.querySelectorAll('tbody tr:not(.section-header-row)');
  if (rows.length === 0) return true; // No rows to check
  
  let relevantRows = Array.from(rows);
  
  // Filter rows by phase if specified
  if (phase) {
    relevantRows = relevantRows.filter(row => {
      const statusCell = row.querySelector('td:nth-child(7)');
      return statusCell && statusCell.textContent.includes(phase);
    });
    
    if (relevantRows.length === 0) return true; // No relevant rows
  }
  
  // Check each row for PASSED/FAILED status
  return relevantRows.every(row => {
    // Skip message rows
    if (row.classList.contains('section-header-row') || 
        row.querySelector('td[colspan="5"]') || 
        row.querySelector('td[colspan="6"]') || 
        row.querySelector('td[colspan="7"]') || 
        row.querySelector('td[colspan="8"]')) {
      return true;
    }
    
    const statusCell = row.querySelector('td:nth-child(7)');
    if (!statusCell) return true;
    
    const statusText = statusCell.textContent;
    return statusText.indexOf('PASSED') !== -1 || statusText.indexOf('FAILED') !== -1;
  });
}
// Update section header buttons based on data
function updateSectionHeaderButtons() {
  const currentPhase = document.querySelector("#currentPhase")?.textContent || "Review";
  const rightSection = document.querySelector('.section-header .right-section');
  
  if (!rightSection) return;
  
  // Clear existing buttons
  rightSection.innerHTML = '';
  
  // Add the appropriate button based on current phase
  if (currentPhase === "Review") {
    // For P1 Reviews
    const p1Rows = document.querySelectorAll('#declaredResultsTable tbody tr:not(.section-header-row)');
    const hasP1Data = Array.from(p1Rows).some(row => {
      const statusCell = row.querySelector('td:nth-child(7)');
      return statusCell && statusCell.textContent.includes('P1');
    });
    
    // For P3 Reviews
    const hasP3Data = Array.from(p1Rows).some(row => {
      const statusCell = row.querySelector('td:nth-child(7)');
      return statusCell && statusCell.textContent.includes('P3');
    });
    
    // Add P1 button if we have P1 data
    if (hasP1Data) {
      const p1Button = document.createElement('button');
      p1Button.id = 'finalizeP1Button';
      p1Button.textContent = 'Finalize P1 Review';
      p1Button.addEventListener('click', function() {
        if (checkAllApplicantsMarked('P1')) {
          document.getElementById('notifyApplicantsModal').style.display = 'block';
          
          // Update modal title and content
          const modalTitle = document.querySelector('#notifyApplicantsModal h2');
          if (modalTitle) {
            modalTitle.textContent = "Confirm P1 Review Finalization";
          }
          
          // Update confirm button
          const confirmButton = document.getElementById('confirmButton');
          if (confirmButton) {
            // Remove existing event listeners
            const newConfirmButton = confirmButton.cloneNode(true);
            confirmButton.parentNode.replaceChild(newConfirmButton, confirmButton);
            
            newConfirmButton.addEventListener('click', function() {
  console.log("Finalizing P1 review process...");

  // Extract status updates from rows in the declared results table
  const declaredResultsTable = document.getElementById("declaredResultsTable");
  const rows = declaredResultsTable?.querySelectorAll('tbody tr:not(.section-header-row)') || [];

  // Arrays to store passed and failed user IDs
  const passedUserIds = [];
  const failedUserIds = [];

  // Process each row to determine which users passed and which failed
  rows.forEach(row => {
    // Skip message rows
    if (row.querySelector('td[colspan]')) return;
    
    const statusCell = row.querySelector('td:nth-child(7)');
    const userId = row.getAttribute('data-userid');
    
    if (statusCell && userId) {
      const statusText = statusCell.textContent.trim();
      
      // Only include P1 rows
      if (statusText.includes('P1')) {
        // Check for PASSED with or without "Pending Finalization"
        if (statusText.includes('PASSED')) {
          passedUserIds.push(userId);
          console.log(`Added ${userId} to passed list (${statusText})`);
        } 
        // Check for FAILED with or without "Pending Finalization"
        else if (statusText.includes('FAILED')) {
          failedUserIds.push(userId);
          console.log(`Added ${userId} to failed list (${statusText})`);
        }
      }
    }
  });

  // If no applicants are selected, show an error
  if (passedUserIds.length === 0 && failedUserIds.length === 0) {
    alert("No P1 applicants found with PASSED or FAILED status.");
    closeModal('notifyApplicantsModal');
    return;
  }

  console.log(`Finalizing P1 Review: ${passedUserIds.length} passed, ${failedUserIds.length} failed`);

  // Show confirmation with counts
  const confirmMessage = `You are about to finalize the P1 review process for ${passedUserIds.length + failedUserIds.length} applicants:
- ${passedUserIds.length} will be PASSED and proceed to next stage
- ${failedUserIds.length} will be FAILED and notified of rejection

This action is irreversible. Are you sure you want to proceed?`;

  if (!confirm(confirmMessage)) {
    closeModal('notifyApplicantsModal');
    return;
  }

  // Show loading indicator
  const confirmButton = document.getElementById('confirmButton');
  if (confirmButton) {
    confirmButton.textContent = "Processing...";
    confirmButton.disabled = true;
  }

  // Send API request for P1 finalization
  fetch('/linemanager/applicant-tracker-jobposition/finalizeP1Review', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({
      passedUserIds: passedUserIds,
      failedUserIds: failedUserIds
    }),
  })
  .then(response => response.json())
  .then(data => {
    if (data.success) {
      alert(`P1 Review finalization complete! All applicants have been notified of their status.
      
${data.passedCount} applicants passed
${data.failedCount} applicants failed`);
      
      // Update local status for any rows that were marked as pending
      rows.forEach(row => {
        const statusCell = row.querySelector('td:nth-child(7)');
        const rowUserId = row.getAttribute('data-userid');
        
        if (statusCell && rowUserId) {
          const currentStatus = statusCell.textContent.trim();
          
          // Update any pending statuses to their final form
          if (currentStatus.includes('P1') && currentStatus.includes('Pending Finalization')) {
            if (currentStatus.includes('PASSED')) {
              statusCell.textContent = 'P1 - PASSED';
            } else if (currentStatus.includes('FAILED')) {
              statusCell.textContent = 'P1 - FAILED';
            }
          }
        }
      });
      
      // Clear the pending status changes after finalization
      window.pendingStatusChanges = {};
      
      closeModal('notifyApplicantsModal');
      
      // Refresh the view after finalization
      setTimeout(() => {
        // Trigger current filter to refresh the view
        const activeFilter = document.querySelector(".filter-button.active");
        if (activeFilter) {
          activeFilter.click();
        } else {
          // Default to "all" if no active filter found
          document.getElementById("filter-all").click();
        }
      }, 500);
    } else {
      alert("Error finalizing P1 review: " + (data.message || "Unknown error"));
      
      // Reset button state
      if (confirmButton) {
        confirmButton.textContent = "Confirm";
        confirmButton.disabled = false;
      }
    }
  })
  .catch(error => {
    console.error("Error finalizing P1 review:", error);
    alert("Failed to finalize P1 review. Please try again.");
    
    // Reset button state
    if (confirmButton) {
      confirmButton.textContent = "Confirm";
      confirmButton.disabled = false;
    }
  });
});
          }
        } else {
          alert("Not all P1 applicants have been marked as passed or failed. Please make a decision for all applicants first.");
        }
      });
      rightSection.appendChild(p1Button);
    }
    
    // Add P3 button if we have P3 data
    if (hasP3Data) {
      const p3Button = document.createElement('button');
      p3Button.id = 'finalizeP3Button';
      p3Button.textContent = 'Finalize P3 Review';
      p3Button.addEventListener('click', function() {
        if (checkAllApplicantsMarked('P3')) {
          document.getElementById('notifyApplicantsModal').style.display = 'block';
          
          // Update modal title and content
          const modalTitle = document.querySelector('#notifyApplicantsModal h2');
          if (modalTitle) {
            modalTitle.textContent = "Confirm P3 Review Finalization";
          }
          
          // Update confirm button
          const confirmButton = document.getElementById('confirmButton');
          if (confirmButton) {
            // Remove existing event listeners
            const newConfirmButton = confirmButton.cloneNode(true);
            confirmButton.parentNode.replaceChild(newConfirmButton, confirmButton);
            
            // Add new event listener with inline function instead of finalizeP3Review
            newConfirmButton.addEventListener('click', function() {
              console.log("Finalizing P3 review process...");
              
              // Extract status updates from rows in the declared results table
              const declaredResultsTable = document.getElementById("declaredResultsTable");
              const rows = declaredResultsTable?.querySelectorAll('tbody tr:not(.section-header-row)') || [];
              
              // Arrays to store passed and failed user IDs
              const passedUserIds = [];
              const failedUserIds = [];
              
              // Process each row to determine which users passed and which failed
              rows.forEach(row => {
                // Skip message rows
                if (row.querySelector('td[colspan]')) return;
                
                const statusCell = row.querySelector('td:nth-child(7)');
                const userId = row.getAttribute('data-userid');
                
                if (statusCell && userId) {
                  const statusText = statusCell.textContent.trim();
                  
                  // Only include P3 rows
                  if (statusText.includes('P3')) {
                    if (statusText.includes('PASSED')) {
                      passedUserIds.push(userId);
                      console.log(`Added ${userId} to passed list (${statusText})`);
                    } else if (statusText.includes('FAILED')) {
                      failedUserIds.push(userId);
                      console.log(`Added ${userId} to failed list (${statusText})`);
                    }
                  }
                }
              });
              
              // If no applicants are selected, show an error
              if (passedUserIds.length === 0 && failedUserIds.length === 0) {
                alert("No P3 applicants found with PASSED or FAILED status.");
                closeModal('notifyApplicantsModal');
                return;
              }
              
              console.log(`Finalizing P3 Review: ${passedUserIds.length} passed, ${failedUserIds.length} failed`);
              
              // Show confirmation with counts
              const confirmMessage = `You are about to finalize the P3 review process for ${passedUserIds.length + failedUserIds.length} applicants:
            - ${passedUserIds.length} will be PASSED and receive job offers
            - ${failedUserIds.length} will be FAILED and notified of rejection

            This action is irreversible. Are you sure you want to proceed?`;

              if (!confirm(confirmMessage)) {
                closeModal('notifyApplicantsModal');
                return;
              }
              
              // Show loading indicator
              const confirmButton = document.getElementById('confirmButton');
              if (confirmButton) {
                confirmButton.textContent = "Processing...";
                confirmButton.disabled = true;
              }
              
              // Send API request for P3 finalization
              fetch('/linemanager/applicant-tracker-jobposition/finalizeP3Review', {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                  passedUserIds: passedUserIds,
                  failedUserIds: failedUserIds
                }),
              })
              .then(response => response.json())
              .then(data => {
                if (data.success) {
                  alert(`P3 Review finalization complete! All applicants have been notified of their status.
                  
            ${data.passedCount} applicants passed
            ${data.failedCount} applicants failed`);
                  
                  // Clear the pending status changes after finalization
                  window.pendingStatusChanges = {};
                  
                  closeModal('notifyApplicantsModal');
                  
                  // Refresh the view after finalization
                  setTimeout(() => {
                    // Trigger current filter to refresh the view
                    const activeFilter = document.querySelector(".filter-button.active");
                    if (activeFilter) {
                      activeFilter.click();
                    } else {
                      // Default to "all" if no active filter found
                      document.getElementById("filter-all").click();
                    }
                  }, 500);
                } else {
                  alert("Error finalizing P3 review: " + (data.message || "Unknown error"));
                  
                  // Reset button state
                  if (confirmButton) {
                    confirmButton.textContent = "Confirm";
                    confirmButton.disabled = false;
                  }
                }
              })
              .catch(error => {
                console.error("Error finalizing P3 review:", error);
                alert("Failed to finalize P3 review. Please try again.");
                
                // Reset button state
                if (confirmButton) {
                  confirmButton.textContent = "Confirm";
                  confirmButton.disabled = false;
                }
              });
              
              // Close the modal
              closeModal('notifyApplicantsModal');
            });
          }
        } else {
          alert("Not all P3 applicants have been marked as passed or failed. Please make a decision for all applicants first.");
        }
      });
      rightSection.appendChild(p3Button);
    }
  }
}


// Handle the "For Evaluation" filter
function handleEvaluationFilter(onboardingHeader, onboardingTable, allMainRows) {
  // Hide onboarding section for evaluation filter
  if (onboardingHeader) onboardingHeader.style.display = 'none';
  if (onboardingTable) onboardingTable.style.display = 'none';
  
  // Update the current phase display
  const phaseSpans = document.querySelectorAll('#currentPhase');
  phaseSpans.forEach(span => span.textContent = 'Evaluation');
  
  // Show the applicant status section even if empty
  const applicantStatusSection = document.getElementById("applicantStatusSection");
  if (applicantStatusSection) {
    applicantStatusSection.style.display = 'block';
  }
  
  // Clear previous rows in both tables
  const awaitingActionTable = document.getElementById("awaitingActionTable");
  const declaredResultsTable = document.getElementById("declaredResultsTable");
  const declaredHeader = document.querySelector('h4:nth-of-type(2)');
  
  if (awaitingActionTable) {
    const tbody = awaitingActionTable.querySelector('tbody');
    if (tbody) tbody.innerHTML = '';
  }
  
  if (declaredResultsTable) {
    const tbody = declaredResultsTable.querySelector('tbody');
    if (tbody) tbody.innerHTML = '';
  }
  
  // Filter rows with "For Evaluation" button or specific status
  const evaluationRows = [];
  
  allMainRows.forEach((row, index) => {
    const lastCell = row.querySelector('td:last-child');
    if (!lastCell) return;
    
    // Check status text
    const statusSpan = lastCell.querySelector('span');
    if (!statusSpan) return;
    
    const statusText = statusSpan.textContent.trim();
    let matched = false;
    
    // Check for P2 and P3 evaluation statuses
    if (statusText.indexOf("P2 - Awaiting for HR Evaluation") !== -1 || 
        statusText.indexOf("P3 - Awaiting for Line Manager Evaluation") !== -1) {
      matched = true;
    }
    
    // If not matched by status, check for button
    if (!matched) {
      // Look for "For Evaluation" button
      const hasEvaluationButton = Array.from(lastCell.querySelectorAll('button')).some(button => 
        button.textContent.trim() === 'For Evaluation'
      );
      
      // Also check for buttons inside anchor tags
      const hasEvaluationLinkButton = Array.from(lastCell.querySelectorAll('a')).some(a => {
        const button = a.querySelector('button');
        return button && button.textContent.trim() === 'For Evaluation';
      });
      
      if (hasEvaluationButton || hasEvaluationLinkButton) {
        matched = true;
      }
    }
    
    if (matched) {
      evaluationRows.push(extractRowData(row, index));
    }
  });
  
  // Ensure the awaiting section and table are displayed
  const awaitingHeader = document.querySelector('h4:nth-of-type(1)');
  if (awaitingHeader) {
    awaitingHeader.textContent = 'Applicants Awaiting Evaluation';
    awaitingHeader.style.display = 'block';
  }
  
  if (awaitingActionTable) {
    awaitingActionTable.style.display = 'table';
  }
  
  // Ensure the tables have proper headers
  ensureTableHeaders();
  
  // Add rows to awaiting action table
  if (awaitingActionTable) {
    const tbody = awaitingActionTable.querySelector('tbody');
    if (tbody) {
      // Empty the tbody first
      tbody.innerHTML = '';
      
      if (evaluationRows.length > 0) {
        evaluationRows.forEach((rowData, idx) => {
          const newRow = createTableRow(rowData, false);  // No toggle for evaluation
          tbody.appendChild(newRow);
          
          // Set userId attribute on the row for score lookup
          if (rowData.userId) {
            newRow.setAttribute('data-userid', rowData.userId);
          }
          
          // Use actual score for this user
          updateScoreCellWithFormatting(newRow, rowData.totalScore);
        });
      } else {
        tbody.innerHTML = `<tr><td colspan="7" class="text-center">No applicants awaiting evaluation.</td></tr>`;
      }
    }
  }
  
  // Hide declared results section as it's not needed for "For Evaluation"
  if (declaredHeader) {
    declaredHeader.style.display = 'none';
  }
  
  if (declaredResultsTable) {
    declaredResultsTable.style.display = 'none';
  }
  
  const sortSection = document.querySelector('.sort-section');
  if (sortSection) {
    sortSection.style.display = 'none';
  }
  
  // Fix scores after a short delay
  setTimeout(window.fixAllTableScores, 300);
  
  // Highlight the active filter button
  highlightActiveFilter('forevaluation');
}




// Manually extract userIds and scores
function manuallyExtractUserIdsAndScores() {
  console.log("Manually extracting userIds and scores...");
  
  // This function directly extracts the backend associations between
  // applicant rows and their userIds and scores
  
  // 1. First, get all rows in the main table
  const mainTable = document.getElementById('mainApplicantTable');
  if (!mainTable) {
    console.log("Main table not found");
    return;
  }
  
  const rows = mainTable.querySelectorAll('tbody tr');
  console.log(`Found ${rows.length} rows in main table`);
  
  // Initialize the global mapping objects if they don't exist
  if (!window.applicantsScores) window.applicantsScores = {};
  if (!window.applicantNameMapping) window.applicantNameMapping = {};
  if (!window.applicantEmailMapping) window.applicantEmailMapping = {};
  
  // 2. Process each row to extract and map the data
  rows.forEach((row, index) => {
    // Extract userId from review buttons or attributes
    let userId = null;
    let totalScore = null;
    
    // Get the name and email for mapping
    const nameCell = row.querySelector('td:nth-child(2)');
    let name = '';
    let email = '';
    
    if (nameCell) {
      const content = nameCell.innerHTML;
      // Extract name and email from content
      const nameParts = content.split('<br>');
      if (nameParts.length > 0) {
        name = nameParts[0].trim();
      }
      
      if (nameParts.length > 1) {
        email = nameParts[1].replace(/<[^>]*>/g, '').trim();
      }
    }
    
    // Method 1: Try to get userId from review button
    const reviewButton = row.querySelector('.btn-review');
    if (reviewButton) {
      const onclick = reviewButton.getAttribute('onclick') || '';
      const userIdMatch = onclick.match(/lineManagerInitialScreeningModal\s*\(\s*['"]([^'"]*)['"]/);
      
      if (userIdMatch && userIdMatch[1]) {
        userId = userIdMatch[1];
        console.log(`Row ${index}: Found userId ${userId} in review button`);
        
        // Also try to extract score from the same onclick
        const scoreMatch = onclick.match(/},\s*['"]([^'"]*)['"]/);
        if (scoreMatch && scoreMatch[1]) {
          totalScore = scoreMatch[1];
          console.log(`Row ${index}: Found score ${totalScore} in review button`);
        }
      }
    }
    
    // Store the data in our global mappings
    if (userId) {
      if (totalScore) {
        window.applicantsScores[userId] = totalScore;
      }
      
      if (name) {
        window.applicantNameMapping[name] = userId;
      }
      
      if (email) {
        window.applicantEmailMapping[email] = userId;
      }
      
      // Store as data attributes on the row for future reference
      row.setAttribute('data-userid', userId);
      row.setAttribute('data-applicant-userid', userId);
      if (totalScore) {
        row.setAttribute('data-score', totalScore);
      }
    }
  });
  
  console.log("Manually extracted mapping data:");
  console.log("- Scores:", window.applicantsScores);
  console.log("- Names:", window.applicantNameMapping);
  console.log("- Emails:", window.applicantEmailMapping);
}




// Set up toggle status buttons
function setupToggleStatusButtons() {
const buttons = document.querySelectorAll('.btn-toggle-status:not([data-has-listener])');
console.log(`Setting up ${buttons.length} toggle status buttons`);

buttons.forEach(button => {
    // Mark that we've added a listener to avoid duplicates
    button.setAttribute('data-has-listener', 'true');
    
    // Get the userId - either from the button's data attribute or from the parent row
    const userId = button.getAttribute('data-userid') || 
                   button.closest('tr')?.getAttribute('data-userid');
    
    if (userId) {
        // Set initial button state based on current status
        const row = button.closest('tr');
        if (row) {
            const statusCell = row.querySelector('td:nth-child(7)');
            if (statusCell) {
                const currentStatus = statusCell.textContent.trim();
                // Set initial button text and style
                if (currentStatus.includes('PASSED')) {
                    button.textContent = 'Passed';
                    button.classList.add('status-passed');
                    button.classList.remove('status-failed');
                } else if (currentStatus.includes('FAILED')) {
                    button.textContent = 'Failed';
                    button.classList.add('status-failed');
                    button.classList.remove('status-passed');
                } else {
                    button.textContent = 'Toggle';
                }
            }
        }
        
        // Remove existing listener if any
        const newButton = button.cloneNode(true);
        button.parentNode.replaceChild(newButton, button);
        
        // Add click event listener
        newButton.addEventListener('click', function() {
            toggleApplicantStatus(this);
        });
        
        // Mark as having a listener
        newButton.setAttribute('data-has-listener', 'true');
        
        // Ensure userId is set on the button
        if (userId) {
            newButton.setAttribute('data-userid', userId);
        }
    } else {
        console.log(`Button missing userId, cannot set up toggle functionality`);
    }
});

return buttons.length;
}


function fixChangeStatusButtons() {
  console.log("Fixing Change Status buttons...");
  
  // Get all buttons
  const buttons = document.querySelectorAll('.btn-change-status');
  console.log(`Found ${buttons.length} Change Status buttons`);
  
  buttons.forEach((button, index) => {
    // Skip if already fixed
    const existingUserId = button.getAttribute('data-userid');
    if (existingUserId && existingUserId !== 'undefined' && existingUserId !== '') {
      return;
    }
    
    // Get the row
    const row = button.closest('tr');
    if (!row) {
      console.log(`Button ${index}: No parent row found`);
      return;
    }
    
    // Get userId from the row - use our reliable method
    const userId = getReliableUserId(row);
    
    // Only update if we found a valid userId from real data
    if (userId) {
      button.setAttribute('data-userid', userId);
      button.setAttribute('onclick', `changeApplicantStatus('${userId}')`);
      console.log(`Button ${index}: Set userId ${userId} from registry of real data`);
    } else {
      console.log(`Button ${index}: No valid userId found from real data`);
    }
  });
}

// Function to sort declared results
function sortDeclaredResults(sortType) {
const table = document.getElementById('declaredResultsTable');
if (!table) return;

const tbody = table.querySelector('tbody');
if (!tbody) return;

const rows = Array.from(tbody.querySelectorAll('tr:not(.section-header-row)'));

// Keep section header rows in place
const headerRows = Array.from(tbody.querySelectorAll('tr.section-header-row'));

// Group rows by section (P1 and P3)
const p1Rows = rows.filter(row => {
    const statusCell = row.querySelector('td:nth-child(7)');
    return statusCell && statusCell.textContent.includes('P1');
});

const p3Rows = rows.filter(row => {
    const statusCell = row.querySelector('td:nth-child(7)');
    return statusCell && statusCell.textContent.includes('P3');
});

// Sort rows based on selected option
if (sortType === 'ascending' || sortType === 'descending') {
    // Sort by score
    const sortFn = (a, b) => {
        const scoreA = parseFloat(a.getAttribute('data-score') || '0');
        const scoreB = parseFloat(b.getAttribute('data-score') || '0');
        return sortType === 'ascending' ? scoreA - scoreB : scoreB - scoreA;
    };
    
    p1Rows.sort(sortFn);
    p3Rows.sort(sortFn);
} else if (sortType === 'alphabetical') {
    // Sort alphabetically by name
    const sortFn = (a, b) => {
        const nameA = a.querySelector('td:nth-child(2)')?.textContent.trim() || '';
        const nameB = b.querySelector('td:nth-child(2)')?.textContent.trim() || '';
        return nameA.localeCompare(nameB);
    };
    
    p1Rows.sort(sortFn);
    p3Rows.sort(sortFn);
}

// Clear the tbody
tbody.innerHTML = '';

// Add P1 header and rows if we have any
if (p1Rows.length > 0) {
    const p1Header = headerRows.find(row => row.textContent.includes('P1'));
    if (p1Header) tbody.appendChild(p1Header);
    p1Rows.forEach(row => tbody.appendChild(row));
}

// Add P3 header and rows if we have any
if (p3Rows.length > 0) {
    const p3Header = headerRows.find(row => row.textContent.includes('P3'));
    if (p3Header) tbody.appendChild(p3Header);
    p3Rows.forEach(row => tbody.appendChild(row));
}
}

// Add missing toggle columns for declared results table only
function addMissingToggleColumns() {
console.log("Checking for missing Toggle Status columns...");

// ONLY target the declared results table
const declaredResultsTable = document.getElementById('declaredResultsTable');
if (!declaredResultsTable) return;

const rows = declaredResultsTable.querySelectorAll('tbody tr:not(.section-header-row)');
console.log(`Checking ${rows.length} rows in declaredResultsTable`);

rows.forEach(row => {
    // Skip message rows (those with colspan)
    if (row.querySelector('td[colspan]')) return;
    
    // Check if the row already has enough columns
    const cells = row.querySelectorAll('td');
    if (cells.length < 8) {
        console.log("Found row missing Toggle Status column");
        
        // Get the userId from the row
        const userId = row.getAttribute('data-userid');
        
        // Create the toggle button cell
        const toggleCell = document.createElement('td');
        toggleCell.innerHTML = `<button class="btn-toggle-status">Toggle Status</button>`;
        row.appendChild(toggleCell);
        
        // If we have a userId, set it on the button
        if (userId) {
            const button = toggleCell.querySelector('.btn-toggle-status');
            if (button) {
                button.setAttribute('data-userid', userId);
            }
        }
    }
});

// After adding missing columns, set up the event listeners
setupToggleStatusButtons();
}




// Update Job Offer section
function updateJobOfferSection(jobOfferRows, container) {
console.log("Updating job offer section with", jobOfferRows.length, "rows");

// Check if job offer section already exists
let jobOfferSection = document.getElementById('jobOfferSection');
let jobOfferTable = document.getElementById('jobOfferTable');

// If we have job offer rows, create or update the section
if (jobOfferRows.length > 0) {
    if (!jobOfferSection) {
        // Create the job offer section if it doesn't exist
        jobOfferSection = document.createElement('div');
        jobOfferSection.id = 'jobOfferSection';
        jobOfferSection.innerHTML = `
            <h4>Job Offer Sent</h4>
            <table class="tracking-table" id="jobOfferTable">
                <thead>
                    <tr>
                        <th>Applicant No.</th>
                        <th>Last Name, First Name</th>
                        <th>Department</th>
                        <th>Position Applied</th>
                        <th>Total Score</th>
                        <th>Work Setup/Availability</th>
                        <th>Applicant Status</th>
                    </tr>
                </thead>
                <tbody></tbody>
            </table>
        `;
        
        // Add the section after the declared results table
        const declaredResultsTable = document.getElementById('declaredResultsTable');
        if (declaredResultsTable && container) {
            container.insertBefore(jobOfferSection, declaredResultsTable.nextSibling);
        }
        
        // Get reference to the new table
        jobOfferTable = document.getElementById('jobOfferTable');
    }
    
    // Update the table content
    if (jobOfferTable) {
        const jobOfferTbody = jobOfferTable.querySelector('tbody');
        if (jobOfferTbody) {
            // Clear existing rows
            jobOfferTbody.innerHTML = '';
            
            // Add each job offer row
            jobOfferRows.forEach((rowData, idx) => {
                const newRow = createTableRow(rowData, false); // No toggle status for job offers
                jobOfferTbody.appendChild(newRow);
                
                // Set userId attribute for score lookup
                if (rowData.userId) {
                    newRow.setAttribute('data-userid', rowData.userId);
                    getTotalScoreDirectly(rowData.userId, newRow);
                }
            });
        }
    }
    
    // Show the section
    if (jobOfferSection) {
        jobOfferSection.style.display = 'block';
    }
} else if (jobOfferSection) {
    // Hide the section if no job offer rows
    jobOfferSection.style.display = 'none';
}
}

// Update section visibilities
function updateReviewSectionsVisibility(hasAwaitingRows, hasDeclaredRows, hasJobOfferRows, hasP1Data, hasP3Data) {
console.log("Updating section visibility:", {
    hasAwaitingRows, hasDeclaredRows, hasJobOfferRows, hasP1Data, hasP3Data
});

// Get references to elements
const awaitingHeader = document.querySelector('h4:nth-of-type(1)');
const declaredHeader = document.querySelector('h4:nth-of-type(2)');
const jobOfferHeader = document.querySelector('h4:nth-of-type(3)');

const awaitingActionTable = document.getElementById('awaitingActionTable');
const declaredResultsTable = document.getElementById('declaredResultsTable');
const jobOfferTable = document.getElementById('jobOfferTable');

const sortSection = document.querySelector('.sort-section');

// Show/hide awaiting action section
if (awaitingHeader) {
    awaitingHeader.style.display = hasAwaitingRows ? 'block' : 'none';
}

if (awaitingActionTable) {
    awaitingActionTable.style.display = hasAwaitingRows ? 'table' : 'none';
}

// Show/hide declared results section
if (declaredHeader) {
    declaredHeader.style.display = hasDeclaredRows ? 'block' : 'none';
}

if (declaredResultsTable) {
    declaredResultsTable.style.display = hasDeclaredRows ? 'table' : 'none';
}

if (sortSection) {
    sortSection.style.display = hasDeclaredRows ? 'block' : 'none';
}

// Show/hide job offer section
if (jobOfferHeader) {
    jobOfferHeader.style.display = hasJobOfferRows ? 'block' : 'none';
}

if (jobOfferTable) {
    jobOfferTable.style.display = hasJobOfferRows ? 'table' : 'none';
}
// Handle the notifyAllApplicants button if it exists (for backward compatibility)
// We're now using dynamic buttons instead of updating text
// Call updateSectionHeaderButtons to refresh the button state
updateSectionHeaderButtons();
// Call updateSectionHeaderButtons if we're already on the review filter
const activeFilter = document.querySelector(".filter-button.active");
if (activeFilter && activeFilter.id === 'filter-forreview') {
setTimeout(updateSectionHeaderButtons, 500); // Small delay to ensure data is loaded
}
}

// Fix scores in declared results table specifically
function fixScoresInDeclaredResults() {
console.log("Fixing scores in declared results table");

const declaredResultsTable = document.getElementById('declaredResultsTable');
if (!declaredResultsTable) return;

// Get all rows (excluding headers)
const rows = declaredResultsTable.querySelectorAll('tbody tr:not(.section-header-row)');
console.log(`Checking ${rows.length} rows in declared results table`);

rows.forEach((row, idx) => {
    // Skip rows with message (colspan)
    if (row.querySelector('td[colspan]')) return;
    
    // Try getting userId from data attribute
    let userId = row.getAttribute('data-userid');
    
    if (!userId) {
        // If no userId, try to extract from name
        const nameCell = row.querySelector('td:nth-child(2)');
        if (nameCell) {
            const name = nameCell.textContent.trim().replace(/\s+/g, ' ');
            userId = findUserIdByNameImproved(name);
            
            // Set the userId on the row if found
            if (userId) {
                row.setAttribute('data-userid', userId);
                
                // Also set userId on toggle button if it exists
                const toggleButton = row.querySelector('.btn-toggle-status');
                if (toggleButton) toggleButton.setAttribute('data-userid', userId);
            }
        }
    }
    
    // If we now have a userId, update the score
    if (userId) {
        console.log(`Row ${idx}: Using userId ${userId} to get score`);
        // Try to get the score from database
        getTotalScoreDirectly(userId, row);
    }
});
}

function displayUploadedDocument(fileUrl, linkId, previewId) {
  const docLink = document.getElementById(linkId);
  const docPreview = document.getElementById(previewId);

  if (!docLink || !docPreview) {
    console.error(`Element not found: linkId=${linkId}, previewId=${previewId}`);
    return;
  }

  // Handle empty or invalid URLs
  if (!fileUrl || fileUrl === '#' || fileUrl === 'undefined' || fileUrl === 'null') {
    docLink.href = "#";
    docLink.textContent = "No document uploaded";
    docPreview.innerHTML = ""; // Clear preview
    return;
  }

  // Valid URL exists, set the link
  docLink.href = fileUrl;
  docLink.textContent = "View Uploaded Document";
  docLink.target = "_blank"; // Open in new tab
  
  // Try to determine file type for preview
  const fileExtension = fileUrl.split('.').pop().toLowerCase();

  // Choose preview method based on file type
  if (["jpg", "jpeg", "png", "gif", "webp"].includes(fileExtension)) {
    // Image preview
    docPreview.innerHTML = `<img src="${fileUrl}" alt="Document Preview" style="max-width: 100%; max-height: 300px; border: 1px solid #ccc; padding: 5px;">`;
  } else if (fileExtension === "pdf") {
    // PDF preview
    docPreview.innerHTML = `<iframe src="${fileUrl}" width="100%" height="300px" style="border: 1px solid #ccc;"></iframe>`;
  } else {
    // For other file types, just show a download link with icon
    docPreview.innerHTML = `
      <div style="text-align: center; margin: 10px 0;">
        <i class="fas fa-file-download" style="font-size: 24px; color: #124A5C;"></i>
        <p>Preview not available. Click the link above to download.</p>
      </div>
    `;
  }

  console.log(`Document preview setup for ${fileUrl} (${fileExtension})`);
}
// Improved function for the Line Manager Initial Screening Modal
function lineManagerInitialScreeningModal(userId, lastName, firstName, birthday, email, phoneNo, scores, verdict, degreeUrl, certUrl, resumeUrl) {
  console.log('Modal Data:', { 
    userId, lastName, firstName, birthday, email, phoneNo, 
    scores, verdict, 
    degreeUrl, certUrl, resumeUrl 
  });

  // If userId is missing or "undefined", log an error and stop further processing.
  if (!userId || userId === "undefined") {
    console.error("Invalid userId passed to modal:", userId);
    alert("Error: Invalid User ID. Cannot display applicant details.");
    return;
  }

  // Set the hidden input value for userId
  document.getElementById('userId').value = userId;

  // Set the hidden input value for jobId if it exists
  const jobIdElement = document.getElementById('jobId');
  if (jobIdElement && typeof jobId !== 'undefined') {
    jobIdElement.value = jobId;
  }

  // Optionally hide the applicantId container if not needed
  let applicantIdContainer = document.getElementById("applicantId")?.parentElement;
  if (applicantIdContainer) {
    applicantIdContainer.style.display = "none";
  }

  // Populate visible applicant details
  document.getElementById('applicant-name').textContent = `${lastName}, ${firstName}`;
  document.getElementById('applicant-birthday').textContent = birthday || 'N/A';
  document.getElementById('applicant-email').textContent = email || 'N/A';
  document.getElementById('applicant-contact').textContent = phoneNo || 'N/A';

  // Populate score details
  document.getElementById('score-degree').textContent = scores.degree || 'N/A';
  document.getElementById('score-experience').textContent = scores.experience || 'N/A';
  document.getElementById('score-certifications').textContent = scores.certifications || 'N/A';
  document.getElementById('score-hard-skills').textContent = scores.hardSkills || 'N/A';
  document.getElementById('score-soft-skills').textContent = scores.softSkills || 'N/A';
  document.getElementById('score-work-setup').textContent = scores.workSetup || 'N/A';
  document.getElementById('score-availability').textContent = scores.availability || 'N/A';

  document.getElementById('computation-verdict').textContent = verdict || 'N/A';

  // Clean up URL values to avoid undefined or null strings
  const cleanDegreeUrl = (degreeUrl && degreeUrl !== 'undefined' && degreeUrl !== 'null') ? degreeUrl : '#';
  const cleanCertUrl = (certUrl && certUrl !== 'undefined' && certUrl !== 'null') ? certUrl : '#';
  const cleanResumeUrl = (resumeUrl && resumeUrl !== 'undefined' && resumeUrl !== 'null') ? resumeUrl : '#';

  // Console log URLs for debugging
  console.log('Document URLs for preview:', {
    degree: cleanDegreeUrl,
    cert: cleanCertUrl,
    resume: cleanResumeUrl
  });

  // Display documents separately with the improved function
  displayUploadedDocument(cleanDegreeUrl, "degree-doc", "degree-preview");
  displayUploadedDocument(cleanCertUrl, "cert-doc", "cert-preview");
  displayUploadedDocument(cleanResumeUrl, "resume-doc", "resume-preview");

  // Display the modal
  document.getElementById('lineManagerInitialScreeningModalHtml').style.display = 'block';

  // Store this score in our global cache - this is the applicant_initialscreening_assessment.totalScore
  if (!window.applicantsScores) window.applicantsScores = {};
  window.applicantsScores[userId] = verdict;
}
// Function to open standard modals
function openModal(modalId, applicantName) {
const modal = document.getElementById(modalId);
if (!modal) {
    console.error(`Modal ${modalId} not found`);
    return;
}

// If this is the job offer modal, update the name
if (modalId === 'releaseJobOfferModal' && applicantName) {
    const nameElement = document.getElementById('applicant-name-job-offer');
    if (nameElement) {
        nameElement.textContent = applicantName;
    }
}

// Display the modal
modal.style.display = 'block';
}

// Function to close standard modals
function closeModal(modalId) {
const modal = document.getElementById(modalId);
if (modal) {
    modal.style.display = 'none';
}
}

// Function to approve Line Manager
function approveLineManager(applicantId) {
if (!applicantId) {
    alert("Error: Missing applicant ID");
    return;
}

// Make API call to approve
fetch('/linemanager/applicant-tracker-jobposition/postApproveLineManager', {
    method: 'POST',
    headers: {
        'Content-Type': 'application/json',
    },
    body: JSON.stringify({ applicantId: applicantId }),
})
.then(response => response.json())
.then(data => {
    if (data.success) {
        alert("Successfully approved applicant!");
        
        // Refresh the view
        setTimeout(() => {
            const activeFilter = document.querySelector(".filter-button.active");
            if (activeFilter) {
                activeFilter.click();
            } else {
                document.getElementById("filter-all").click();
            }
        }, 500);
    } else {
        alert("Error approving applicant: " + (data.message || "Unknown error"));
    }
})
.catch(error => {
    console.error("Error:", error);
    alert("Failed to approve applicant.");
});
}

// Function to handle notification for job offers
function sendNotification() {
// This would normally send notifications to applicants
alert("Notification sent to applicant!");
closeModal('releaseJobOfferModal');

// Refresh the view after sending notification
setTimeout(() => {
    const activeFilter = document.querySelector(".filter-button.active");
    if (activeFilter) {
        activeFilter.click();
    }
}, 500);
}

// Function to handle onboarding confirmation
function confirmOnboarding() {
alert("Applicant moved to onboarding");
closeModal('moveToOnboardingModal');

// Refresh the view
setTimeout(() => {
    document.getElementById("filter-foronboarding").click();
}, 500);
}

// Function to handle account setup confirmation
function confirmAccountSetup() {
alert("Account setup confirmed");
closeModal('accountSetupReminderModal');
}

// Function to set interview availabilities (placeholder)
function setInterviewAvailabilities() {
// This would normally open Calendly or another scheduling tool
alert("Opening Calendly to set interview availabilities...");
// window.open('https://calendly.com/your-calendly-link', '_blank');
}

// Handle the Pass button click in the modal
function passApplicant() {
const userId = document.getElementById('userId').value;
if (!userId) {
    alert("Error: Invalid User ID");
    return;
}

// Make API call to update status in line manager's view
fetch('/linemanager/applicant-tracker-jobposition/markAsP1Passed', {
    method: 'POST',
    headers: {
        'Content-Type': 'application/json',
    },
    body: JSON.stringify({ userId: userId }),
})
.then(response => response.json())
.then(data => {
    if (data.success) {
        // Close the modal
        document.getElementById('lineManagerInitialScreeningModalHtml').style.display = 'none';
        
        // Record this in the pending changes
        if (!window.pendingStatusChanges) {
            window.pendingStatusChanges = {};
        }
        window.pendingStatusChanges[userId] = 'PASSED';
        
        // Move the row from awaiting action to declared results
        setTimeout(() => {
            // First try to find the row in the awaiting action table
            const awaitingTable = document.getElementById('awaitingActionTable');
            const declaredTable = document.getElementById('declaredResultsTable');
            
            if (awaitingTable && declaredTable) {
                const moveResult = moveRowToSection(userId, 'awaitingActionTable', 'declaredResultsTable');
                
                if (!moveResult) {
                    console.log("Row movement failed, refreshing view");
                    // If movement fails, refresh the entire view
                    const activeFilter = document.querySelector(".filter-button.active");
                    if (activeFilter) {
                        activeFilter.click();
                    } else {
                        document.getElementById("filter-all").click();
                    }
                }
            }
        }, 300);
        
        // Show success message
        alert("Successfully marked applicant status as PASSED! The applicant will be notified when you finalize the review.");
        
    } else {
        alert("Error updating applicant status: " + (data.message || "Unknown error"));
    }
})
.catch(error => {
    console.error("Error:", error);
    alert("Failed to update applicant status.");
});
}

// Handle the Reject button click in the modal
function rejectApplicant() {
    const userId = document.getElementById('userId').value;
    if (!userId) {
        alert("Error: Invalid User ID");
        return;
    }
    
    // Make API call to update status in line manager's view
    fetch('/linemanager/applicant-tracker-jobposition/markAsP1Failed', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({ userId: userId }),
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            // Close the modal
            document.getElementById('lineManagerInitialScreeningModalHtml').style.display = 'none';
            
            // Record this in the pending changes
            if (!window.pendingStatusChanges) {
                window.pendingStatusChanges = {};
            }
            window.pendingStatusChanges[userId] = 'FAILED';
            
            // Move the row from awaiting action to declared results
            setTimeout(() => {
                const moveResult = moveRowToSection(userId, 'awaitingActionTable', 'declaredResultsTable');
                
                if (!moveResult) {
                    console.log("Row movement failed, refreshing view");
                    // If movement fails, refresh the entire view
                    const activeFilter = document.querySelector(".filter-button.active");
                    if (activeFilter) {
                        activeFilter.click();
                    } else {
                        document.getElementById("filter-all").click();
                    }
                }
            }, 300);
            
            // Show success message
            alert("Successfully marked applicant status as FAILED! The applicant will be notified when you finalize the review.");
            
        } else {
            alert("Error updating applicant status: " + (data.message || "Unknown error"));
        }
    })
    .catch(error => {
        console.error("Error:", error);
        alert("Failed to update applicant status.");
    });
}



// 3. Improved function to get total scores for a given userId
function captureInitialScreeningScores() {
console.log("Capturing initial screening scores from lineManagerInitialScreeningModal buttons");

// Get all buttons with lineManagerInitialScreeningModal in their onclick
const reviewButtons = document.querySelectorAll('button[onclick*="lineManagerInitialScreeningModal"]');

if (!window.applicantsScores) {
    window.applicantsScores = {};
}

if (!window.applicantNameMapping) {
    window.applicantNameMapping = {};
}

reviewButtons.forEach(button => {
    const onclickAttr = button.getAttribute('onclick') || '';
    
    try {
        // Extract userId
        const userIdMatch = onclickAttr.match(/lineManagerInitialScreeningModal\s*\(\s*['"]([^'"]*)['"]/);
        if (userIdMatch && userIdMatch[1]) {
            const userId = userIdMatch[1];
            
            // Extract name for mapping
            const row = button.closest('tr');
            if (row) {
                const nameCell = row.querySelector('td:nth-child(2)');
                if (nameCell) {
                    const name = nameCell.textContent.replace(/\s+/g, ' ').trim();
                    window.applicantNameMapping[name] = userId;
                }
            }
            
            // Extract score (after the closing brace of scores object)
            const scoreMatch = onclickAttr.match(/},\s*['"]([^'"]*)['"]/);
            if (scoreMatch && scoreMatch[1]) {
                const score = scoreMatch[1];
                
                // Cache the score
                window.applicantsScores[userId] = score;
                console.log(`Cached score ${score} for userId ${userId}`);
            }
        }
    } catch (error) {
        console.error('Error parsing button onclick:', error);
    }
});

console.log(`Captured ${Object.keys(window.applicantsScores).length} scores`);
}

function getTotalScoreDirectly(userId, targetRow) {
  if (!userId || !targetRow) {
    console.log("Missing userId or targetRow, cannot get score");
    return;
  }
  
  console.log(`Looking for direct score for userId: ${userId}`);
  
  // Add data-userid attribute to the row for future reference
  targetRow.setAttribute('data-userid', userId);
  
  // 1. First check the global cache
  if (window.applicantsScores && window.applicantsScores[userId]) {
    const cachedScore = window.applicantsScores[userId];
    console.log(`Using cached score ${cachedScore} for userId ${userId}`);
    updateScoreCellWithFormatting(targetRow, cachedScore);
    return;
  }
  
  // 2. Get all review buttons from the main table and other tables
  const allReviewButtons = document.querySelectorAll('.btn-review');
  let foundScore = false;
  
  for (const button of allReviewButtons) {
    const onclickAttr = button.getAttribute('onclick') || '';
    
    // First check if this button is for the correct userId
    if (onclickAttr.includes(`lineManagerInitialScreeningModal('${userId}'`) || 
        onclickAttr.includes(`lineManagerInitialScreeningModal("${userId}"`)) {
      
      // Parse parameters to extract the score
      try {
        // The score is passed as a parameter after the data object
        const params = onclickAttr.match(/lineManagerInitialScreeningModal\s*\((.*?)\)/);
        if (params && params[1]) {
          const paramList = params[1].split(',');
          
          // The score is after the object closing bracket
          // Find the index of the closing bracket }
          const closingBracketIndex = paramList.findIndex(p => p.includes('}'));
          if (closingBracketIndex >= 0 && paramList.length > closingBracketIndex + 1) {
            // The next parameter after the closing bracket is the score
            const scoreParam = paramList[closingBracketIndex + 1].trim();
            // Remove quotes
            const score = scoreParam.replace(/['"]/g, '');
            
            console.log(`Extracted score from button: ${score}`);
            
            // Cache the score
            if (!window.applicantsScores) window.applicantsScores = {};
            window.applicantsScores[userId] = score;
            
            // Update the cell
            updateScoreCellWithFormatting(targetRow, score);
            foundScore = true;
            break;
          }
        }
      } catch (error) {
        console.error('Error parsing button parameters:', error);
      }
    }
  }
  
  // 3. If still not found, try to find it in initial screening data
  if (!foundScore) {
    // Get all buttons in the document with this userId
    const allButtons = document.querySelectorAll(`button[onclick*="${userId}"]`);
    
    for (const button of allButtons) {
      const onclickAttr = button.getAttribute('onclick') || '';
      if (onclickAttr.includes('lineManagerInitialScreeningModal')) {
        try {
          // The score is after the closing brace of the scores object
          const match = onclickAttr.match(/},\s*['"]([^'"]*)['"]/);
          if (match && match[1]) {
            const score = match[1];
            
            console.log(`Found score ${score} from onclick attribute for userId ${userId}`);
            
            // Cache the score
            if (!window.applicantsScores) window.applicantsScores = {};
            window.applicantsScores[userId] = score;
            
            // Update the cell
            updateScoreCellWithFormatting(targetRow, score);
            foundScore = true;
            break;
          }
        } catch (error) {
          console.error('Error extracting score from button:', error);
        }
      }
    }
  }
  
  // 4. If score still not found, use N/A
  if (!foundScore) {
    console.log(`No score found for userId ${userId}, using N/A`);
    updateScoreCellWithFormatting(targetRow, 'N/A');
  }
}


    // Function to handle moving rows between sections
    function moveRowToSection(userId, fromSection, toSection) {
    console.log(`Moving user ${userId} from ${fromSection} to ${toSection}`);
    
    if (!userId || !fromSection || !toSection) {
        console.error("Missing required parameters for row movement");
        return false;
    }
    
    // Get source and target tables
    const sourceTable = document.getElementById(fromSection);
    const targetTable = document.getElementById(toSection);
    
    if (!sourceTable || !targetTable) {
        console.error(`Tables not found: ${fromSection} or ${toSection}`);
        return false;
    }
    
    // Find the row in the source table
    const sourceRows = sourceTable.querySelectorAll('tbody tr');
    let rowToMove = null;
    let rowData = null;
    
    for (const row of sourceRows) {
        // Skip section headers and message rows
        if (row.classList.contains('section-header-row') || row.querySelector('td[colspan]')) {
            continue;
        }
        
        const rowUserId = row.getAttribute('data-userid');
        if (rowUserId === userId) {
            rowToMove = row;
            // Extract the row data before removing it
            rowData = extractRowData(row, 0);
            break;
        }
    }
    
    if (!rowToMove || !rowData) {
        console.error(`Row for user ${userId} not found in ${fromSection}`);
        return false;
    }
    
    // Remove the row from source table
    rowToMove.remove();
    
    // Check if we need to add a "no data" message to source table if it's now empty
    const remainingSourceRows = Array.from(sourceTable.querySelectorAll('tbody tr')).filter(
        row => !row.classList.contains('section-header-row') && !row.querySelector('td[colspan]')
    );
    
    if (remainingSourceRows.length === 0) {
        const sourceTbody = sourceTable.querySelector('tbody');
        if (sourceTbody) {
            // Get column count from table headers
            const headerCount = sourceTable.querySelectorAll('thead th').length;
            const messageRow = document.createElement('tr');
            const messageCell = document.createElement('td');
            messageCell.setAttribute('colspan', headerCount.toString());
            messageCell.className = 'text-center no-data-message';
            messageCell.textContent = 'No applicants awaiting review.';
            messageRow.appendChild(messageCell);
            sourceTbody.appendChild(messageRow);
        }
    }
    
    // Add row to target table with appropriate modifications
    const targetTbody = targetTable.querySelector('tbody');
    if (!targetTbody) {
        console.error(`Target tbody not found in ${toSection}`);
        return false;
    }
    
    // Clear any "no data" message in the target table
    const noDataRow = targetTbody.querySelector('tr td[colspan].text-center');
    if (noDataRow) {
        noDataRow.closest('tr').remove();
    }
    
    // Create new row for target table
    // Special handling for declaredResultsTable - add Toggle Status column
    const needsToggleColumn = (toSection === 'declaredResultsTable');
    const newRow = createTableRow(rowData, needsToggleColumn);
    
    // Set the same userId on the new row
    newRow.setAttribute('data-userid', userId);
    
    // Get section header row that matches P1 or P3
    const isP1 = rowData.cells[6].includes('P1');
    const headerSelector = isP1 ? 'P1' : 'P3';
    
    // Add the row after the appropriate section header
    const sectionHeaders = targetTbody.querySelectorAll('tr.section-header-row');
    let inserted = false;
    
    for (const header of sectionHeaders) {
        if (header.textContent.includes(headerSelector)) {
            // Try to add after the header
            const nextSibling = header.nextSibling;
            if (nextSibling) {
                targetTbody.insertBefore(newRow, nextSibling);
            } else {
                targetTbody.appendChild(newRow);
            }
            inserted = true;
            break;
        }
    }
    
    // If no matching header found, just append to the end
    if (!inserted) {
        targetTbody.appendChild(newRow);
    }
    
    // If moving to declared results, set up the toggle button
    if (needsToggleColumn) {
        const toggleButton = newRow.querySelector('.btn-toggle-status');
        if (toggleButton) {
            toggleButton.setAttribute('data-userid', userId);
            setupToggleStatusButtons();
        }
    }
    
    // Update the score in the new row
    if (window.applicantsScores && window.applicantsScores[userId]) {
        updateScoreCellWithFormatting(newRow, window.applicantsScores[userId]);
    } else {
        getTotalScoreDirectly(userId, newRow);
    }
    
    return true;
    }
    
    // Special debug function to understand why userIds aren't being found
function debugUserIdExtraction() {
  console.log("=== DEBUG: Analyzing Review Buttons ===");
  
  // Get all review buttons
  const reviewButtons = document.querySelectorAll('.btn-review');
  console.log(`Found ${reviewButtons.length} review buttons to analyze`);
  
  // Examine each button
  reviewButtons.forEach((button, index) => {
    console.log(`\nAnalyzing button ${index}:`);
    
    // Get the onclick attribute
    const onclickAttr = button.getAttribute('onclick') || '';
    console.log(`onClick attribute: ${onclickAttr.substring(0, 100)}...`);
    
    // Try different regex patterns to extract userId
    console.log("Trying different extraction patterns:");
    
    // Pattern 1: Standard pattern
    const pattern1 = /lineManagerInitialScreeningModal\s*\(\s*['"]([^'"]*)['"]/;
    const match1 = onclickAttr.match(pattern1);
    console.log(`Pattern 1 result: ${match1 ? match1[1] : 'No match'}`);
    
    // Pattern 2: More flexible pattern
    const pattern2 = /lineManagerInitialScreeningModal\s*\(\s*([^,]+)/;
    const match2 = onclickAttr.match(pattern2);
    console.log(`Pattern 2 result: ${match2 ? match2[1].replace(/['"]/g, '') : 'No match'}`);
    
    // Pattern 3: Get all parameters
    const pattern3 = /lineManagerInitialScreeningModal\s*\((.*?)\)/;
    const match3 = onclickAttr.match(pattern3);
    if (match3) {
      const params = match3[1].split(',').map(p => p.trim());
      console.log(`Pattern 3 found ${params.length} parameters:`);
      params.slice(0, 5).forEach((p, i) => console.log(`  Param ${i}: ${p}`));
    } else {
      console.log(`Pattern 3 result: No match`);
    }
    
    // Get the row and try to find other identifiers
    const row = button.closest('tr');
    if (row) {
      const nameCell = row.querySelector('td:nth-child(2)');
      if (nameCell) {
        const name = nameCell.textContent.trim();
        console.log(`Row name: ${name}`);
      }
      
      // Look for hidden inputs or data attributes
      const hiddenInputs = row.querySelectorAll('input[type="hidden"]');
      if (hiddenInputs.length > 0) {
        console.log(`Found ${hiddenInputs.length} hidden inputs in the row`);
        hiddenInputs.forEach(input => {
          console.log(`  Hidden input: name=${input.name}, value=${input.value}`);
        });
      }
      
      // Check all data attributes
      const dataAttrs = Array.from(row.attributes)
        .filter(attr => attr.name.startsWith('data-'))
        .map(attr => `${attr.name}="${attr.value}"`);
      
      if (dataAttrs.length > 0) {
        console.log(`Found ${dataAttrs.length} data attributes: ${dataAttrs.join(', ')}`);
      }
    }
  });
  
  // Now check the applicants data in window.applicantsData
  console.log("\n=== DEBUG: Checking window.applicantsData ===");
  if (window.applicantsData && Array.isArray(window.applicantsData)) {
    console.log(`Found ${window.applicantsData.length} applicants in window.applicantsData`);
    if (window.applicantsData.length > 0) {
      const sample = window.applicantsData[0];
      console.log("Sample applicant data structure:");
      console.log(JSON.stringify(sample, null, 2).substring(0, 300) + "...");
      
      // Check if we have userIds
      const userIds = window.applicantsData
        .map(a => a.userId)
        .filter(id => id && id !== 'undefined');
      
      console.log(`Found ${userIds.length} valid userIds in applicantsData`);
      if (userIds.length > 0) {
        console.log(`Sample userIds: ${userIds.slice(0, 5).join(', ')}`);
      }
    }
  } else {
    console.log("window.applicantsData is not available or not an array");
  }
  
  // Check if there's an applicants-data element 
  const dataElement = document.getElementById('applicants-data');
  if (dataElement) {
    console.log("Found applicants-data element in the DOM");
    try {
      const data = JSON.parse(dataElement.textContent);
      console.log(`Parsed ${data.length || 0} items from applicants-data element`);
    } catch (err) {
      console.log(`Error parsing applicants-data element: ${err.message}`);
    }
  } else {
    console.log("No applicants-data element found in the DOM");
  }
}

// Last resort: Assign userIds based on data from API or manual values
function lastResortUserIdAssignment() {
  console.log("=== LAST RESORT: Manual userId assignment ===");
  
  // Get data directly from the API response if available
  let userIds = [];
  
  // Try to get userIds from applicantsData
  if (window.applicantsData && Array.isArray(window.applicantsData)) {
    userIds = window.applicantsData
      .map(a => a.userId)
      .filter(id => id && id !== 'undefined' && id !== '');
      
    console.log(`Found ${userIds.length} userIds in applicantsData`);
  }
  
  // If no userIds found, create dummy IDs as a last resort
  if (userIds.length === 0) {
    console.log("No userIds found in data, creating temporary IDs");
    // Create temporary unique IDs by using timestamps
    userIds = ['temp-user-' + Date.now(), 'temp-user-' + (Date.now() + 1)];
  }
  
  // Get all change status buttons
  const buttons = document.querySelectorAll('.btn-change-status');
  console.log(`Assigning ${userIds.length} userIds to ${buttons.length} buttons`);
  
  // Assign userIds to buttons
  buttons.forEach((button, index) => {
    if (index < userIds.length) {
      const userId = userIds[index];
      console.log(`Assigning userId ${userId} to button ${index}`);
      
      // Set userId on button
      button.setAttribute('data-userid', userId);
      button.setAttribute('onclick', `changeApplicantStatus('${userId}')`);
      
      // Also set on parent row
      const row = button.closest('tr');
      if (row) {
        row.setAttribute('data-userid', userId);
      }
    }
  });
  
  // Now fix the buttons to use the assigned userIds
  setTimeout(() => {
    console.log("Checking if assigned userIds are being used");
    buttons.forEach((button, index) => {
      const userId = button.getAttribute('data-userid');
      if (userId && userId !== 'undefined' && !userId.startsWith('undefined')) {
        console.log(`Button ${index} has userId: ${userId}`);
      } else {
        console.log(`Button ${index} STILL has no valid userId!`);
      }
    });
  }, 500);
}

    
    // Add this code block right at the end of your <script> section
    // This will quickly and directly fix the immediate issue by running outside of any function
    setTimeout(function() {
    console.log("*** EMERGENCY FIX: Direct userId injection for Change Status buttons ***");
    
    // Get all Change Status buttons
    const buttons = document.querySelectorAll('.btn-change-status');
    console.log(`Found ${buttons.length} Change Status buttons for direct fix`);
    
    // Fix each button
    buttons.forEach((button, index) => {
    // First try to get userId from row
    const row = button.closest('tr');
    let userId = row ? row.getAttribute('data-userid') : null;
    
    // If no userId, try from name cell
    if (!userId && row) {
      const nameCell = row.querySelector('td:nth-child(2)');
      if (nameCell) {
        const nameCellText = nameCell.textContent.trim();
        console.log(`Button ${index}: Row name cell text: "${nameCellText}"`);
        
        // DIRECT FIX - extract the first part (name) and match against the known email
        const nameParts = nameCellText.split('\n');
        if (nameParts.length > 0) {
          const name = nameParts[0].trim();
          console.log(`Button ${index}: Extracted name: "${name}"`);
          
          // Look for a matching userId
          // This is the main lookup - if we know the userId for any row with this name, use it
          const matchingUserIdRow = document.querySelector(`tr[data-userid][data-name="${name}"]`);
          if (matchingUserIdRow) {
            userId = matchingUserIdRow.getAttribute('data-userid');
            console.log(`Button ${index}: Found matching row with userId ${userId} for name "${name}"`);
          }
        }
      }
    }
    
    // If we've found a userId, update the button
    if (userId && userId !== 'undefined' && userId !== '') {
      button.setAttribute('data-userid', userId);
      button.setAttribute('onclick', `changeApplicantStatus('${userId}')`);
      console.log(`Button ${index}: DIRECT FIX APPLIED - Set userId to ${userId}`);
      
      // Also update the row if it exists
      if (row) {
        row.setAttribute('data-userid', userId);
      }
    } else {
      console.log(`Button ${index}: DIRECT FIX FAILED - No userId found`);
    }
    });
    }, 2000);

// Setup modal event listeners
function setupModalEventListeners() {
    console.log("Setting up modal event listeners");
    
    // Event listeners for notifyAllApplicants modal
    document.getElementById('notifyAllApplicants')?.addEventListener('click', function() {
        document.getElementById('notifyApplicantsModal').style.display = 'block';
    });
    
    // Close buttons for all modals
    document.querySelectorAll('.close-button').forEach(button => {
        button.addEventListener('click', function() {
            const modalId = this.closest('.modal').id;
            document.getElementById(modalId).style.display = 'none';
        });
    });
    
    // Back buttons for all modals
    document.querySelectorAll('.back-button, .review-modal-back-button').forEach(button => {
        button.addEventListener('click', function() {
            const modalId = this.closest('.modal')?.id || this.closest('.review-modal')?.id;
            if (modalId) {
                document.getElementById(modalId).style.display = 'none';
            }
        });
    });
}

// Add these functions to your existing JavaScript

// Handle passing an applicant
function p3passApplicant(applicantId) {
    if (!applicantId) {
        console.error('Missing applicantId for pass action');
        alert('Error: Cannot identify the applicant to pass.');
        return;
    }
    
    if (!confirm('Are you sure you want to PASS this applicant? This will update their status to P3 - PASSED and notify them.')) {
        return;
    }
    
    // Show loading indicator
    const actionButton = event.target;
    const originalText = actionButton.textContent;
    actionButton.textContent = 'Processing...';
    actionButton.disabled = true;
    
    // Send API request to pass the applicant
    fetch('/handle-pass-applicant', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({ applicantId: applicantId }),
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            alert('Applicant has been successfully passed! They will be notified.');
            
            // Update the status display in the table
            const row = actionButton.closest('tr');
            if (row) {
                const statusSpan = row.querySelector('td:nth-child(5) span');
                if (statusSpan) {
                    statusSpan.textContent = 'P3 - PASSED';
                }
                
                // Replace buttons with a message
                const actionsDiv = actionButton.closest('div');
                if (actionsDiv) {
                    actionsDiv.innerHTML = '<div style="color: green; font-weight: bold;">Applicant has been passed</div>';
                }
            }
        } else {
            alert('Error: ' + (data.message || 'Failed to pass applicant'));
            
            // Restore button state
            actionButton.textContent = originalText;
            actionButton.disabled = false;
        }
    })
    .catch(error => {
        console.error('Error:', error);
        alert('An error occurred while processing your request. Please try again.');
        
        // Restore button state
        actionButton.textContent = originalText;
        actionButton.disabled = false;
    });
}

// Handle rejecting an applicant
function p3rejectApplicant(applicantId) {
    if (!applicantId) {
        console.error('Missing applicantId for reject action');
        alert('Error: Cannot identify the applicant to reject.');
        return;
    }
    
    // Prompt for rejection reason
    const reason = prompt('Please provide a reason for rejecting this applicant:', 'Not a good fit for the position');
    
    if (reason === null) {
        // User cancelled the prompt
        return;
    }
    
    if (!confirm('Are you sure you want to REJECT this applicant? This will update their status to P3 - FAILED and notify them.')) {
        return;
    }
    
    // Show loading indicator
    const actionButton = event.target;
    const originalText = actionButton.textContent;
    actionButton.textContent = 'Processing...';
    actionButton.disabled = true;
    
    // Send API request to reject the applicant
    fetch('/handle-reject-applicant', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({ 
            applicantId: applicantId,
            reason: reason
        }),
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            alert('Applicant has been rejected. They will be notified.');
            
            // Update the status display in the table
            const row = actionButton.closest('tr');
            if (row) {
                const statusSpan = row.querySelector('td:nth-child(5) span');
                if (statusSpan) {
                    statusSpan.textContent = 'P3 - FAILED';
                }
                
                // Replace buttons with a message
                const actionsDiv = actionButton.closest('div');
                if (actionsDiv) {
                    actionsDiv.innerHTML = '<div style="color: red; font-weight: bold;">Applicant has been rejected</div>';
                }
            }
        } else {
            alert('Error: ' + (data.message || 'Failed to reject applicant'));
            
            // Restore button state
            actionButton.textContent = originalText;
            actionButton.disabled = false;
        }
    })
    .catch(error => {
        console.error('Error:', error);
        alert('An error occurred while processing your request. Please try again.');
        
        // Restore button state
        actionButton.textContent = originalText;
        actionButton.disabled = false;
    });
}

</script>
</body>
</html>
